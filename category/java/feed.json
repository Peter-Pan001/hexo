{
    "version": "https://jsonfeed.org/version/1",
    "title": "理 想 净 土 • All posts by \"java\" category",
    "description": "不必匆忙，不必火花四溅，不必成为别人，只需成为自己",
    "home_page_url": "https://peter-pan001.github.io/my-blog",
    "items": [
        {
            "id": "https://peter-pan001.github.io/my-blog/Java/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BOV/",
            "url": "https://peter-pan001.github.io/my-blog/Java/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BOV/",
            "title": "Java网络编程OV",
            "date_published": "2021-03-25T02:39:52.000Z",
            "content_html": "<h1 id=\"Java网络编程OV\"><a href=\"#Java网络编程OV\" class=\"headerlink\" title=\"Java网络编程OV\"></a>Java网络编程OV</h1><h2 id=\"一、入门\"><a href=\"#一、入门\" class=\"headerlink\" title=\"一、入门\"></a>一、入门</h2><h3 id=\"1-1-软件结构\"><a href=\"#1-1-软件结构\" class=\"headerlink\" title=\"1.1 软件结构\"></a>1.1 软件结构</h3><ul>\n<li><strong>C/S结构</strong>： Client/Server,客户端访问数据库服务器</li>\n<li><strong>B/S结构</strong>： Browser/Server,浏览器访问数据库服务器</li>\n<li><font color=greed>两种架构都离不开网络的支持</font>\n\n</li>\n</ul>\n<h3 id=\"1-2-网络通信协议\"><a href=\"#1-2-网络通信协议\" class=\"headerlink\" title=\"1.2 网络通信协议\"></a>1.2 网络通信协议</h3><ul>\n<li><strong>TCP/IP协议</strong>：传输控制协议/因特网互联协议，是Internet最基本、最广泛的协议，它定义了计算机如何连入因特网，以及数据如何在他们之间进行传输的标准。<br>| 分层模型 | 相应的协议 |<br>|————-:|————:|<br>|应用层| HTTP、FTP、SMTP、SNMP、DNS|<br>|传输层|TCP、UDP|<br>|网络层|ICMP、IGMP、IP、ARP、RARP|<br>|数据链路层||<br>|物理层||</li>\n</ul>\n<h3 id=\"1-3-主要协议分类\"><a href=\"#1-3-主要协议分类\" class=\"headerlink\" title=\"1.3 主要协议分类\"></a>1.3 主要协议分类</h3><ul>\n<li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol),UDP是无连接的通信协议，不考虑数据是否发送成功，即为不可靠连接，典型的例子有<strong>发短信</strong>（发送端发送数据，不会确认接收端是否存在，并且接收端也不会反馈到发送端是否接收到数据）</p>\n<ul>\n<li>但UDP的优点也很明显，消耗资源少，通讯效率高，所以对于音频、视频的传输时，偶尔出现丢包的现象也不会对最终的数据结果产生太大的影响</li>\n<li>在传输重要数据的时候，不建议使用UDP协议</li>\n<li>数据被限定在64KB以内</li>\n</ul>\n</li>\n<li><p><strong>TCP</strong>：传输控制协议(Transmission Control Protocol),TCP是面向连接的通信协议，在通信之前，发送端和接收端必须建立逻辑连接，即确保发送端和接收端存在，再进行数据的传输，由客户端(发送端)对服务器(接收端)发送连接请求，即三次握手！</p>\n<ul>\n<li>三次握手：TCP协议中，发送数据的准备阶段，由客户端和服务端进行三次交互，确保连接的可靠<ul>\n<li>第一次握手：客户端向服务端发送连接请求，等待客户端收到连接请求</li>\n<li>第二次握手：服务端向客户端应答，通知客户端已收到连接请求</li>\n<li>第三次握手：客户端再次向服务端发送确认信息，确认连接<br><img data-src=\"./image/三次握手.png\" alt=\"三次握手\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-4网络编程三要素\"><a href=\"#1-4网络编程三要素\" class=\"headerlink\" title=\"1.4网络编程三要素\"></a>1.4网络编程三要素</h3><h4 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h4><ul>\n<li>计算机网络通信的规则<h4 id=\"IP地址\"><a href=\"#IP地址\" class=\"headerlink\" title=\"IP地址\"></a>IP地址</h4></li>\n<li>互联网协议地址</li>\n<li>IP地址分类<ul>\n<li>IPv4 ：一个32位的二进制数，被分成四个字节，都是0-255之间的整数，最多有42亿个，现在已经枯竭</li>\n<li>IPv6：一个128位的地址，每16个字节为一组，分成8组的十六进制数</li>\n</ul>\n</li>\n<li>常用命令<ul>\n<li>查看本机ip地址<pre><code class=\"lang-bash\">ipconfig\n</code></pre>\n</li>\n<li>检查网络是否连通<pre><code class=\"lang-bash\">ping 空格 ip地址\nping 192.168.1.2\n</code></pre>\n<h4 id=\"端口号\"><a href=\"#端口号\" class=\"headerlink\" title=\"端口号\"></a>端口号</h4></li>\n</ul>\n</li>\n<li><strong>端口号</strong>是一个<font color=red>逻辑端口</font>，我们无法直接看到，只能借助一些软件进行查看，当我们使用网络软件时，操作系统会自动为网络软件分配一个随机的端口号或者由系统指定端口号</li>\n<li>端口号的长度<ul>\n<li>是由2个字节组成，取值范围在0-65535之间</li>\n</ul>\n</li>\n<li><font color=red>注意：\n- 1024之前的端口不能使用，因为已经被系统分配给一些已知的网络软件\n- 网络软件的端口号不能重复</font></li>\n<li>常见的端口号<ol>\n<li>80端口： 网络端口， www.baidu.com：80</li>\n<li>数据库  MySQL ：3306  Oracle：1521</li>\n<li>Tomcat服务器 ：8080 <h2 id=\"二、TCP通信程序\"><a href=\"#二、TCP通信程序\" class=\"headerlink\" title=\"二、TCP通信程序\"></a>二、TCP通信程序</h2><h3 id=\"2-1-概述\"><a href=\"#2-1-概述\" class=\"headerlink\" title=\"2.1 概述\"></a>2.1 概述</h3></li>\n</ol>\n<ul>\n<li>TCP通信时两台计算机实现数据交互，<strong>必须区分客户端和服务端</strong></li>\n<li>通信的步骤：</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>服务端程序要提前启动，等待客户端的连接（就像你玩LOL一样，必须下载客户端应用程序，才能对LOL服务端（区服）进行访问）</li>\n<li>客户端主动连接服务端，连接成功才能进行通信，但<font color=blue>服务端不能主动连接客户端</font>，只能被动连接<ul>\n<li><strong><font color=purple>Java中用于实现TCP通信的两个类</font></strong></li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><strong><font color=purple>客户端</font></strong>：<code>java java.net.Socket</code>类表示，创建<code>Socket</code>对象，向服务端发送连接请求，服务端响应请求，两端建立连接开始通信</li>\n<li><strong><font color=purple>服务端</font></strong>：<code>java.net.ServerSocket</code>类表示，创建<code>ServerSocket</code>对象，相当于开启了一个服务，并等待客户端连接</li>\n</ul>\n<ul>\n<li>服务端必须明确的两件事<ol>\n<li>多个客户端和服务器进行交互，服务器必须明确和哪个客户端进行交互——<strong>在服务端有一个accept方法获取请求客户端对象</strong></li>\n<li>多个客户端和服务端进行交互，就需要多个IO流对象<ol>\n<li><font color=greed>服务端没有IO流，服务器可以请求客户端对象Socket</li>\n<li>使用每个客户端Socket中提供的IO流和客户端进行交互&lt;/font&gt; </li>\n<li><font color=purple>服务器使用客户端的字节输入流读取客户端发送的数据</li>\n<li>服务器使用客户端的字节输出流给客户端回写数据&lt;/font&gt;<ul>\n<li><strong><font color=red>即服务器端使用客户端的流与客户端进行交互</font></strong><br><img data-src=\"./image/服务端与客户端通信.png\" alt=\"服务端与客户端通信\"></li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"2-2-Socket-类\"><a href=\"#2-2-Socket-类\" class=\"headerlink\" title=\"2.2 Socket 类\"></a>2.2 Socket 类</h3><ul>\n<li><code>Socket</code>类：该类实现客户端套接字，套接字指的是两台设备之间通信的端点<h4 id=\"TCP客户端\"><a href=\"#TCP客户端\" class=\"headerlink\" title=\"TCP客户端\"></a>TCP客户端</h4><h5 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a><strong>构造方法</strong></h5><ul>\n<li><code>public Socket(String host ,int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号，如果指定的host是null，则相当于指定地址为回环地址127.x.x.x</li>\n<li>参数：<ul>\n<li><code>String host</code> ：服务器主机名/服务器IP地址</li>\n<li><code>int port</code> ：服务器端口号<h5 id=\"成员方法\"><a href=\"#成员方法\" class=\"headerlink\" title=\"成员方法\"></a><strong>成员方法</strong></h5></li>\n</ul>\n</li>\n<li><code>OutputStream getOutputStream();</code> 返回此套接字的输出流</li>\n<li><code>InputStream getInputStream():</code> 返回该套接字的输入流</li>\n<li><code>void close();</code> 关闭此套接字<h5 id=\"实现方法\"><a href=\"#实现方法\" class=\"headerlink\" title=\"实现方法\"></a><strong>实现方法</strong></h5></li>\n</ul>\n<ol>\n<li>创建一个客户端对象Socket，构造方法绑定服务器的ip地址和端口号</li>\n<li>使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象</li>\n<li>使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据</li>\n<li>使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象</li>\n<li>使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据</li>\n<li>释放资源（Socket）</li>\n</ol>\n</li>\n<li><p><strong>注意</strong>：</p>\n<ul>\n<li>客户端和服务端进行交互，必须使用Socket中提供的网络流，不能使用自己创建的流对象</li>\n<li>当我们创建客户端对象Socket时，就会去请求服务器和客户端3次握手建立连接通信<ul>\n<li>服务端没有启动，则抛出异常</li>\n<li>服务端已经启动，可以进行交互</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>代码：</p>\n<pre><code class=\"lang-java\">public class TCPClient{\n    public static void main(String[] args) throws IOException{\n        Socket socket = new Socket(&quot;127.0.0.1&quot;,8888);//ip地址和端口号\n\n        OutputStream os = socket.getOutputStream();\n\n        os.write(&quot;你好服务器&quot;.getBytes());\n\n        InputStream is = socket.getInputStream();\n\n        byte[] bytes = new byte[1024];\n        int len = is.read(bytes);\n        System.out.println(new String(bytes,0,len));\n\n        socket.close();\n    }\n}\n</code></pre>\n<h4 id=\"TCP服务端\"><a href=\"#TCP服务端\" class=\"headerlink\" title=\"TCP服务端\"></a>TCP服务端</h4><h5 id=\"表示服务端的类\"><a href=\"#表示服务端的类\" class=\"headerlink\" title=\"表示服务端的类\"></a><strong>表示服务端的类</strong></h5><ul>\n<li><code>java.net.SreverSocket</code> 此类实现服务器套接字<h5 id=\"构造方法-1\"><a href=\"#构造方法-1\" class=\"headerlink\" title=\"构造方法\"></a><strong>构造方法</strong></h5></li>\n<li><code>ServerSocket(int port)</code> 创建绑定特定端口的服务器套接字</li>\n<li><strong><font color=red>服务器端必须知道是哪个客户端请求的服务器，使用accept方法获取请求的客户端对象Socket</font></strong><h5 id=\"服务器实现步骤\"><a href=\"#服务器实现步骤\" class=\"headerlink\" title=\"服务器实现步骤\"></a><strong>服务器实现步骤</strong></h5></li>\n</ul>\n<ol>\n<li>创建一个服务端对象ServerSocket对象和系统指定的端口号</li>\n<li>使用ServerSocket对象中的方法accept，获取到请求的客户端对象Socket</li>\n<li>使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象</li>\n<li>使用网络字节输入流InputStream对象中的方法read，读取客户端发送的数据</li>\n<li>使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象</li>\n<li>使用网络字节输出流OutputStream对象中的方法write，给客户端回写数据</li>\n<li>释放资源（Socket，ServerSocket）</li>\n</ol>\n</li>\n<li><p>代码:</p>\n<pre><code class=\"lang-java\">public class TCPServer{\n    Public static void main(String[] args) throws IOException{\n        ServerSocket server = new ServerSocket(8888);\n\n        Socket socket = server.accept();\n\n        InputStream is = socket.getInputStream();\n\n        byte[] bytes = new byte[1024];\n        int len = is.read(bytes);\n        System.out.println(new String(bytes,0,len));\n\n        OutputStream os = socket.getOutputStream();\n\n        os.write(&quot;收到谢谢&quot;.getbytes());\n        socket.close();\n        server.close();\n    }\n}\n</code></pre>\n</li>\n</ul>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "https://peter-pan001.github.io/my-blog/Java/Java%E5%9F%BA%E7%A1%80%E6%B7%B7%E5%90%88/",
            "url": "https://peter-pan001.github.io/my-blog/Java/Java%E5%9F%BA%E7%A1%80%E6%B7%B7%E5%90%88/",
            "title": "Java基础混合",
            "date_published": "2021-03-25T02:38:36.000Z",
            "content_html": "<h1 id=\"java基础混合\"><a href=\"#java基础混合\" class=\"headerlink\" title=\"java基础混合\"></a>java基础混合</h1><h2 id=\"01-成员变量与局部变量的区别\"><a href=\"#01-成员变量与局部变量的区别\" class=\"headerlink\" title=\"01 成员变量与局部变量的区别\"></a>01 成员变量与局部变量的区别</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:right\">成员变量</th>\n<th style=\"text-align:right\">局部变量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:right\">在方法的外部，直接写在类中</td>\n<td style=\"text-align:right\">在方法的内部</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">作用在整个类中</td>\n<td style=\"text-align:right\">只有方法当中可以使用，出了方法就不能使用</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">若没有赋值，会存在默认值，与数组规则一致</td>\n<td style=\"text-align:right\">没有默认值，必须必须手动设置默认值</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">位于堆内存中</td>\n<td style=\"text-align:right\">位于栈内存中</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">随着对象创建而产生，随着对象被垃圾回收而消失</td>\n<td style=\"text-align:right\">随着方法进栈而产生，随着方法出栈而消失</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li><p>代码案例：</p>\n<pre><code class=\"lang-java\">public class demo01{\n    String name ; //成员变量\n\n    public void partA(){\n        int num =15; //局部变量\n        System.out.println(num);\n        System.out.println(name);\n    }\n    public void partB(int c){//方法的参数就是局部变量\n\n    //参数在方法调用时，必然会被赋值\n    System.out.println(c);\n    int age;//局部变量，没赋值不可用\n    System.out.println(name);//可在partB中调用成员变量，但不能调用partA的局部变量num\n    }\n}\n</code></pre>\n<h2 id=\"02-关于java修饰符的作用范围\"><a href=\"#02-关于java修饰符的作用范围\" class=\"headerlink\" title=\"02 关于java修饰符的作用范围\"></a>02 关于java修饰符的作用范围</h2></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:right\">访问修饰符</th>\n<th style=\"text-align:right\">本类</th>\n<th style=\"text-align:right\">同包</th>\n<th style=\"text-align:right\">子类</th>\n<th style=\"text-align:right\">其他</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:right\">private</td>\n<td style=\"text-align:right\">√</td>\n<td style=\"text-align:right\"></td>\n<td style=\"text-align:right\"></td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td style=\"text-align:right\">default</td>\n<td style=\"text-align:right\">√</td>\n<td style=\"text-align:right\">√</td>\n<td style=\"text-align:right\"></td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td style=\"text-align:right\">protected</td>\n<td style=\"text-align:right\">√</td>\n<td style=\"text-align:right\">√</td>\n<td style=\"text-align:right\">√</td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td style=\"text-align:right\">public</td>\n<td style=\"text-align:right\">√</td>\n<td style=\"text-align:right\">√</td>\n<td style=\"text-align:right\">√</td>\n<td style=\"text-align:right\">√</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"03-this关键字\"><a href=\"#03-this关键字\" class=\"headerlink\" title=\"03 this关键字\"></a>03 this关键字</h2><ul>\n<li><p>this<br>当方法的局部变量和类的成员变量重名的时候，采用“就近原则”，优先使用局部变量；<br>如果需要访问本类的成员变量，使用格式： this.成员变量名</p>\n</li>\n<li><p>关于this的知识</p>\n<ul>\n<li>通过谁调用的方法谁就是this</li>\n<li>使用this可以区分成员变量和局部变量</li>\n<li>this不能用于静态方法中（静态方法的对象已经实例化！）</li>\n<li>在构造方法中使用时，必须置于构造方法的第一行</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"04-构造方法\"><a href=\"#04-构造方法\" class=\"headerlink\" title=\"04 构造方法\"></a>04 构造方法</h2><ul>\n<li>什么是构造方法？<br>构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法</li>\n<li>构造方法的格式<pre><code class=\"lang-java\"> public 类名称(参数类型 参数名称){\n     方法体\n }\n</code></pre>\n</li>\n<li><p><font color=red>注意：</font></p>\n<ol>\n<li>构造方法的名称必须和所在的类名称完全一样，大小写也必须一样</li>\n<li>构造方法不要写返回值类型（void也不行）</li>\n<li>构造方法不能return一个具体的返回值</li>\n<li>如果没有编写任何构造方法，那么编译器会默认创建一个无参构造方法，方法体什么都不做</li>\n<li>构造方法也可以进行重载（重载：方法名称相同，参数个数\\顺序\\类型不同）</li>\n</ol>\n<ul>\n<li><p>代码展示：</p>\n<pre><code class=\"lang-java\">public class teacher{\n    private String name;\n    private int age;\n    //无其他任何构造方法创建时，会默认创建一个构造方法\n    public teacher(){\n\n    }\n    public teacher(){\n        //无参的构造方法\n        System.out.println(&quot;这是一个构造方法！&quot;);\n    }\n    public teacher(String name, int age ){\n        //有参的构造方法\n        this.name=name;\n        this.age= age;\n    }\n    //get/set构造器\n    public void setName(String name){\n        this.name= name;\n    }\n    public String getName(String name){\n        return name;\n    }\n    public void setAge(int age){\n        this.age= age;\n    }\n    public int getAge(int age){\n        return age;\n    }\n}\n</code></pre>\n</li>\n<li>一个标准的类所需的部分</li>\n</ul>\n<ol>\n<li>所有的成员变量都需用private关键字修饰</li>\n<li>为每一个成员变量编写getting\\setting构造器</li>\n<li>编写一个无参的构造方法</li>\n<li>编写一个有参的构造方法</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"05-Scanner类的使用\"><a href=\"#05-Scanner类的使用\" class=\"headerlink\" title=\"05 Scanner类的使用\"></a>05 Scanner类的使用</h2><ul>\n<li><p>通过使用Scanner类，实现键盘输入功能</p>\n</li>\n<li><p>使用步骤：</p>\n<ol>\n<li>导包 <pre><code class=\"lang-java\">import java.util.Scanner;\n</code></pre>\n</li>\n<li>创建对象<pre><code class=\"lang-java\">Scanner s = new Scanner(System.in);//s为对象名\n</code></pre>\n</li>\n<li>使用对象<br>对象名.成员方法名<pre><code class=\"lang-java\">int num = s.nextInt();//键盘输入一个整型，并赋值给num变量\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"06-匿名对象\"><a href=\"#06-匿名对象\" class=\"headerlink\" title=\"06 匿名对象\"></a>06 匿名对象</h2><ul>\n<li><p>匿名对象的基本了解</p>\n<ul>\n<li>匿名对象就是只有右边的对象，没有左边的名字和赋值运输符</li>\n</ul>\n<p>new 类名();</p>\n<pre><code class=\"lang-java\">new person().name =&quot;大司马&quot;;\nnew person().showName();//此时的匿名对象为全新的，不可引用上次的对象变量\n</code></pre>\n<ul>\n<li>匿名对象只能使用唯一的一次，下次在使用<font color=red>必须创建</font>一个新的对象</li>\n<li>如果确定有一个对象只需使用唯一一次，则可以使用匿名对象</li>\n</ul>\n</li>\n<li><p>键盘输入与传参</p>\n<ul>\n<li>使用匿名对象进行键盘输入<pre><code class=\"lang-java\">int num = new Scanner(System.in).nextInt();\nSystem.out.println(num);\n</code></pre>\n<ul>\n<li>对比一般键盘输入<pre><code class=\"lang-java\">Scanner sc = new Scanner(System.in);\nint num2= sc.nextInt();\nSystem.out.println(num2);\n</code></pre>\n</li>\n</ul>\n</li>\n<li>使用匿名对象传参<pre><code class=\"lang-java\">public class demo01{\n  public static void main (String[] args){\n      methoddemo(new Scanner(System.in));\n  }\n  public static void methoddemo(Scanner sc){\n    int i = sc.nextInt();\n    System.out.println(i);\n  }\n}\n</code></pre>\n</li>\n<li>使用匿名对象用返回值键盘输入<pre><code class=\"lang-java\"> public class demo01{\n  public static void main (String[] args){\n    Scanner sc = methodreturn();\n    int num = sc.nextInt();\n    System.out.println(&quot;输入的值为：&quot;+num);\n  }\n  public static void methodreturn){\n    return new Scanner(System.in);\n  }\n}\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"07-Random类\"><a href=\"#07-Random类\" class=\"headerlink\" title=\"07 Random类\"></a>07 Random类</h2><ul>\n<li>Random类用来生产随机数字</li>\n<li>使用步骤<ol>\n<li>导包<pre><code class=\"lang-java\">import java.util.Random;\n</code></pre>\n2.创建对象<pre><code class=\"lang-java\">Random r = new Random();\n</code></pre>\n3.使用<pre><code class=\"lang-java\">int num = r.nextInt();\n</code></pre>\n</li>\n</ol>\n</li>\n<li><p>有范围的生成随机数</p>\n<pre><code class=\"lang-java\">int n=5;\nRandom r= new Random();\nint result = r.nextInt(n);//范围为[0,n)\nint result2 = r.nextInt(n)+1;//范围为[1,n+1)\n</code></pre>\n<h2 id=\"08-字符串String类\"><a href=\"#08-字符串String类\" class=\"headerlink\" title=\"08 字符串String类\"></a>08 字符串String类</h2></li>\n<li><p>String类概述</p>\n<ul>\n<li>java.lang.String类表示字符串</li>\n<li>String类为<font color=red>final类型是不可修改</font>的，也<font color=red>不能被继承</font>，一旦创建了String对象，他的值就无法改变，如果需要对字符串进行修改，则需要使用StringBuffer或StringBuilder类</li>\n</ul>\n</li>\n<li><p>字符串的特点</p>\n<ul>\n<li>字符串的内容永不改变</li>\n<li>字符串可以共享使用</li>\n<li>底层原理是byte[]字节数组</li>\n</ul>\n</li>\n<li>三种创建方式<ol>\n<li>使用无参构造，创建一个空字符串，无任何内容<pre><code class=\"lang-java\">String str1 = new String();\n</code></pre>\n</li>\n<li>根据字符数组创建字符串<pre><code class=\"lang-java\">Char[] chars = {&#39;A&#39;,&#39;B&#39;,&#39;C&#39;};\nString str2 = new String(charsnum);\n</code></pre>\n</li>\n<li>根据字节数组创建字符串<pre><code class=\"lang-java\">byte[] bytesnum ={97,98,99};\nString str3 = new String(bytesnum);\nSystem.out.println(str3);//打印的是其字节码对应的字符\n</code></pre>\n</li>\n<li>直接创建（本质上也是创建了对象，只不过jvm帮你了！）<pre><code class=\"lang-java\">String str4 = &quot;lesuit&quot;;\n</code></pre>\n</li>\n</ol>\n</li>\n<li><p>字符串比较</p>\n<ul>\n<li>‘==’ 是对对象的地址值进行比较，若比较其内容，可以使用public boolean equals(Object obj)进行比较</li>\n<li>任何对象都能用object进行接收</li>\n<li>equals方法具有对称性，a.equals(b)和b.equals(a)效果一样</li>\n<li>比较的一个是常量一个是字符串时，字符串应该放在前面(“abc”.equals(Str))，否则会报错，出现空指针异常<br>例如：<br>```java<br>String str1 = “Hello”;<br>String str2 = “Hello”;<br>char[] arr = {‘H’,’e’,’l’,’l’,’o’};<br>String str3 = new String(arr);<br>String str4 = “hello”;</li>\n</ul>\n<p>System.out.println(str1.equals(Str2));//显然为true<br>System.out.println(str2.equals(Str1));//true<br>System.out.println(str1.equals(Str3));//true<br>System.out.println(str1.equals(Str4));//false</p>\n<p>String str5 = “black”;<br>System.out.println(“black”.equals(str5));//true,推荐使用<br>System.out.println(str5.equals(“black”));//虽然也为true但会出现空指针异常<br>```</p>\n</li>\n<li><p>字符串的获取</p>\n<ul>\n<li><p>常用方法：</p>\n<ol>\n<li>public int length(),获取字符串当中含有字符的个数，获取字符串长度</li>\n<li>public String concat(String str),将当前字符串和参数字符串拼接成为新的字符串</li>\n<li>public char charAt(int index),获取指定索引位置的单个字符（从0开始）</li>\n<li>public int indexOf(String str),查找参数字符串在本字符串中首次出现的位置，如果没有返回-1<br>```java<br>//获取字符串长度<br>int stringlen = “abcderfhijkouys”.length();<br>System.out.println(“字符串的长度：”+stringlen);<br>//拼接字符串<br>String str1 = “hello”; //hello<br>String str2 = “world”; //world<br>String str3 = str1.concat(str2); //helloworld </li>\n</ol>\n<p>//查找单个字符<br>String str4 = “hello”;<br>char ch = str4.charAt(1);<br>System.out.println(str4+”的第一个字符是”+ch);<br>//查找参数字符串在原字符串出现的第一次的索引位置<br>String str6 = “nothingisimpossiblenothing”;<br>int index = str6.indexOf(“ing”);<br>System.out.println(index);//4<br>```</p>\n</li>\n</ul>\n</li>\n<li>字符串的截取方法<ul>\n<li>public String substring(int index)，截取从参数位置一直到字符串结尾，返回新的字符串</li>\n<li>public String substring(int begin,int end),截取从begin开始end结束的字符串 [begin,end)<pre><code class=\"lang-java\">String str1 = &quot;helloworld&quot;;\nString str2 = str1.substring(5);//world\nstring str3 = str1.substring(3,6);//low\n</code></pre>\n</li>\n</ul>\n</li>\n<li>字符串的常用转换方法<ul>\n<li>public char[] toCharArray(),将当前字符串拆分成字符数组作为返回值</li>\n<li>public byte[] getBytes(),获取当前字符串底层的字节数组</li>\n<li>public String replace(CharSequence oldString,CharSequence newString),将所有出现的原字符串替换为新字符串，返回替换之后的新字符串<pre><code class=\"lang-java\">//转换为字符数组\nchar[] chars = &quot;Hello&quot;.toCharArray();\nSystem.out.println(chars[0]); //H\nSystem.out.println(chars.length); //5\n//转换为字节数组\nbyte[] bytes = &quot;abc&quot;.getBytes();\nfor(int i = 0;i&lt;bytes.length,i++){\nSystem.out.println(byte[i]);\n}\n//内容替换\nString str1= &quot;what the fuck&quot;;\nSting str2= str1.replace(&quot;fuck&quot;,&quot;****&quot;);\nSystem.out.println(str1);//what the fuck\nSystem.out.println(Str2);//what the ****\n</code></pre>\n</li>\n</ul>\n</li>\n<li>字符串分割方法<ul>\n<li>public String[] split(String regex),按照参数的规则，将字符串切分成若干部分</li>\n<li>split方法的参数其实是一个正则表达式，要按照“ . ”进行切分，必须写成”\\.“<pre><code class=\"lang-java\">String str1 =&quot;what a beautiful world&quot;;\nString[] arr1 = str1.split(&quot; &quot;);//逢遇到空格就切割形成新的字符串\nfor(int i = 0; i&lt;arr1.length;i++){\nSystem.out.println(arr1[i]);\n}\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"09-Arrays工具类\"><a href=\"#09-Arrays工具类\" class=\"headerlink\" title=\"09 Arrays工具类\"></a>09 Arrays工具类</h2><ul>\n<li>java.util.Arrays是一个与数组相关的工具类，里面提供了大量的静态方法，用来实现数组场景的操作</li>\n<li>public static String toString(数组名),将参数数组变成字符串[元素1，元素二….]</li>\n<li><p>public static void sort(数组名)，按照默认升序对数组的元素进行排序（若元素为数值，则sort默认升序；若元素为字符串，则sort默认按照字母升序，若为自定义类型，需要通过Comparable接口支持）</p>\n<pre><code class=\"lang-java\">int[] intArray = {10,20,45};\nString intStr = Arrays.toString(inArray);\nSystem.out.println(intstr);\n\nint[] arr1 = {1,5,89,63,12};\nArrays.sort(arr1);\nSystem.out.println(Array.toString(arr1));\n\nString[] arr2 = {&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;};\nArrays.sort(arr2);\nSystem.out.println(Arrays.toString(arr2));\n\n//倒序遍历\nString str = &quot;ahsdhancaciosihd&quot;;\nchar[] chars = str.toCharArray();\nArrays.sort(chars);\nfor(int i =chars.length-1;i&gt;=0;i--){//IDEA快捷键：数组名.forr\n   System.out.println(chars[i]);\n}\n</code></pre>\n</li>\n</ul>\n<h2 id=\"10-Math工具类\"><a href=\"#10-Math工具类\" class=\"headerlink\" title=\"10 Math工具类\"></a>10 Math工具类</h2><ul>\n<li>java.util.Math类是数学相关的工具类，提供大量静态方法，完成与数学相关的操作<ul>\n<li>public static double ads(double num)，获取绝对值</li>\n<li>public static double ceil(double num),向上取整</li>\n<li>public static double floor(double num),向下取整</li>\n<li>public static long round(double num),四舍五入</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"11-抽象类与抽象方法\"><a href=\"#11-抽象类与抽象方法\" class=\"headerlink\" title=\"11 抽象类与抽象方法\"></a>11 抽象类与抽象方法</h2><ul>\n<li>抽象方法<br>就是加上abstract关键字，然后去掉大括号，直接分号结束</li>\n<li>抽象类<br>抽象方法的所在类，必须是抽象类，在class前加abstract关键字</li>\n<li><p>注意：</p>\n<ul>\n<li>不能直接创建new抽象类对象</li>\n<li>必须用一个子类来继承抽象父类</li>\n<li>创建子类对象时进行使用</li>\n<li>抽象类不能创建对象，如果创建，编译无法通过而报错，只能创建其非抽象子类的对象（假设创建了抽象类的对象，调用了抽象类的方法，而抽象方法没有具体的方法体没有意义）</li>\n<li>抽象类中，可以有构造方法，是供子类创建对象时初始化父类使用的（子类的构造方法中，有默认的super()，需要方法父类的构造方法）</li>\n<li>抽象类中，不一定包含抽象方法，但是有抽象方法必定有抽象类（未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计）</li>\n<li>抽象类的子类，必须重写抽象父类中所有的抽象方法<br>```java<br>public abstract class Person{<br>//抽象方法，无方法体<br>public abstract void eat();<br>//普通方法<br>public void eating(){</li>\n</ul>\n<p>}<br>}<br>```</p>\n</li>\n</ul>\n<h2 id=\"12-接口（interface）\"><a href=\"#12-接口（interface）\" class=\"headerlink\" title=\"12 接口（interface）\"></a>12 接口（interface）</h2><ul>\n<li><p>接口概述</p>\n<ul>\n<li>接口就是多个类的公共规范</li>\n<li>接口是一种引用数据类型</li>\n<li>接口都可以定义抽象方法</li>\n<li>接口不能直接使用，必须有一个实现类来实现接口</li>\n</ul>\n</li>\n<li><p>格式：<br>public abstract 返回值类型 方法名（参数列表）; </p>\n</li>\n<li><p>使用步骤</p>\n<ul>\n<li>public class 实现类名 implements 接口名{ }</li>\n<li>接口的实现类必须重写接口的所有抽象方法（去掉abstract，加上方法体）</li>\n<li>创建实现类对象，使用</li>\n</ul>\n</li>\n<li>接口默认方法<ul>\n<li>格式：<ul>\n<li>public default 返回值类型 方法名（参数列表）{  }</li>\n</ul>\n</li>\n<li>使用方法<ol>\n<li>接口的默认方法，可以通过接口实现类对象直接调用</li>\n<li>也可以被接口实现类进行覆盖重写</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>接口静态方法<ul>\n<li>格式：<ul>\n<li>public static返回值类型 方法名（参数列表）{  }</li>\n</ul>\n</li>\n<li>使用方法<ul>\n<li>通过接口名，直接调用其中的静态方法<ul>\n<li>接口名.静态方法名（参数）;</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>接口私有方法<ul>\n<li>使用场景<ul>\n<li>需要抽取一个公有方法，来解决两个默认方法之间代码重复的问题（公有方法不能让实现类使用）</li>\n</ul>\n</li>\n<li>普通私有方法：解决多个默认方法之间重复代码问题<ul>\n<li>private 返回值类型 方法名（参数）{  }</li>\n</ul>\n</li>\n<li>静态私有方法：解决多个静态方法之间重复代码问题<ul>\n<li>private static 返回值类型 方法名（参数）{  }  </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>接口的常量<ul>\n<li>格式<ul>\n<li>public static final 数据类型 常量名 = 数值；<pre><code class=\"lang-java\">public static final int OUT_OF_BUSS = 12;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>关于常量<ul>\n<li>可以省略 public static final</li>\n<li>必须赋值</li>\n<li>常量名必须大写，多个单词用下划线分隔开 </li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "https://peter-pan001.github.io/my-blog/Java/JavaSE%E5%B0%8F%E7%BB%93/",
            "url": "https://peter-pan001.github.io/my-blog/Java/JavaSE%E5%B0%8F%E7%BB%93/",
            "title": "JavaSE小结",
            "date_published": "2021-01-05T02:53:33.000Z",
            "content_html": "<h2 id=\"语言背景\"><a href=\"#语言背景\" class=\"headerlink\" title=\"语言背景\"></a>语言背景</h2><ul>\n<li>Java于1995年诞生，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web引用开发和移动应用开发</li>\n<li>Java有三个版本<ul>\n<li>JavaSE(标准版)</li>\n<li>JavaEE(企业版)</li>\n<li>JavaME(微型版)</li>\n</ul>\n</li>\n<li>2006年发布Hadoop</li>\n<li>JDK：java开发工具包，里面包含了各种用于java程序开发的基本工具包</li>\n<li>JRE：java运行环境</li>\n</ul>\n<h2 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h2><h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><ul>\n<li>单行注释： <code>//</code></li>\n<li>多行注释： <code>/**/</code></li>\n<li>文档注释： <code>/** */</code></li>\n</ul>\n<h3 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a>标识符</h3><ul>\n<li>标识符即关键字，如： <code>public</code>、<code>finally</code>等</li>\n</ul>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><ul>\n<li><p><strong>基本数据类型</strong></p>\n<ul>\n<li><strong>整型</strong><ul>\n<li>byte</li>\n<li>short</li>\n<li>int</li>\n<li>long</li>\n</ul>\n</li>\n<li><strong>字符型</strong><ul>\n<li>char</li>\n</ul>\n</li>\n<li><strong>浮点型</strong><ul>\n<li>double</li>\n<li>int</li>\n</ul>\n</li>\n<li><strong>布尔型</strong><ul>\n<li>boolean</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>引用数据类型</strong></p>\n<ul>\n<li>类</li>\n<li>接口</li>\n<li>数组</li>\n</ul>\n</li>\n<li><strong>类型转换</strong><ul>\n<li>自动转换(低转高)</li>\n<li>强制转换(高转低)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"变量与常量\"><a href=\"#变量与常量\" class=\"headerlink\" title=\"变量与常量\"></a>变量与常量</h3><ul>\n<li><code>type varName [=value];</code></li>\n<li>作用域<ul>\n<li>类变量</li>\n<li>实例变量</li>\n<li>局部变量</li>\n</ul>\n</li>\n<li><p>常量</p>\n<ul>\n<li><code>final MIN_B = 10;</code></li>\n</ul>\n</li>\n<li><p>命名规范</p>\n<ul>\n<li>见名知意</li>\n<li>驼峰命名法</li>\n<li>类命名首字母大写</li>\n<li>常量：&nbsp;大写+下划线</li>\n<li>不使用驼峰命名法</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h3><ul>\n<li><strong>算术运算符</strong><ul>\n<li><code>+,-,*,/,%,++,--</code>&nbsp;(加、减、乘、除、取余数、自增、自减)</li>\n</ul>\n</li>\n<li><strong>赋值运算符</strong><ul>\n<li><code>=</code></li>\n</ul>\n</li>\n<li><strong>关系运算符</strong><ul>\n<li><code>&gt;,&lt;,=&gt;,&lt;=,==,!=</code>&nbsp;<code>instance of</code>&nbsp;(大于、小于、大于等于、小于等于、等于、不等于、判断是否为类的实例化对象)</li>\n</ul>\n</li>\n<li><strong>逻辑运算符</strong><ul>\n<li><code>&amp;&amp;,||,!</code>&nbsp;(与、或、非)</li>\n</ul>\n</li>\n<li><strong>位运算符</strong><ul>\n<li><code>&amp;,|,^,~,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;</code>&nbsp;(位与、位或、位异或、位非、左移、右移、无符号右移)</li>\n</ul>\n</li>\n<li><strong>条件运算符</strong><ul>\n<li><code>?:</code>&nbsp;(表达式 ？ 为真语句 ：为假语句)</li>\n</ul>\n</li>\n<li><strong>扩展运算符</strong><ul>\n<li><code>+=,-=,*=,/=</code>&nbsp;<ul>\n<li><code>a+=2 === a=a+2</code></li>\n<li><code>a*=2 === a==a*2</code></li>\n<li><code>a-=2 === a=a-2</code></li>\n<li><code>a/=2 === a=a/2</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"包机制\"><a href=\"#包机制\" class=\"headerlink\" title=\"包机制\"></a>包机制</h3><ul>\n<li><strong>域名倒写</strong></li>\n<li><strong>防止命名冲突</strong></li>\n<li><code>package</code></li>\n<li><code>import</code></li>\n</ul>\n<h3 id=\"JavaDoc\"><a href=\"#JavaDoc\" class=\"headerlink\" title=\"JavaDoc\"></a>JavaDoc</h3><ul>\n<li><strong>JDK帮助文档</strong></li>\n<li><strong>javadoc</strong><ul>\n<li><code>@author</code></li>\n<li><code>@version</code></li>\n<li><code>@since</code></li>\n<li><code>@param</code></li>\n<li><code>@return</code></li>\n<li><code>@thoows</code></li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"lang-java\">  public Class Welcome {\n    /**\n    * @author theMan\n    * @param args\n    * @since 1.0\n    * @throws 无异常抛出\n    */\n    public static void main(String[] args){\n      System.out.println(&quot;welcome&quot;);\n    }\n  }\n</code></pre>\n<h2 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h2><ul>\n<li><strong>Scanner</strong><ul>\n<li>用户交互&nbsp;<code>System.in</code></li>\n</ul>\n</li>\n<li><strong>顺序结构</strong><ul>\n<li><code>if</code>单选择结构</li>\n<li><code>if-else</code>多选择结构</li>\n<li><code>switch</code>多选结构<ul>\n<li>jdk支持了<code>String</code>类型</li>\n<li><code>case</code>穿透现象</li>\n<li><code>default</code>默认</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>循环结构</strong><ul>\n<li><code>while</code>避免死循环</li>\n<li><code>do-while</code>先执行，后判断</li>\n<li><code>for</code></li>\n<li>增强for循环</li>\n</ul>\n</li>\n<li><strong>特殊</strong><ul>\n<li><code>break</code>跳出循环</li>\n<li><code>continue</code>终止本次循环</li>\n<li><code>return</code>结束方法运行</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><ul>\n<li><strong>何为方法</strong><ul>\n<li>修饰符 返回值 方法名(参数名){return 返回值;}</li>\n</ul>\n</li>\n<li><strong>方法调用</strong><ul>\n<li><code>类名.方法</code></li>\n<li><code>对象.方法</code></li>\n</ul>\n</li>\n<li><strong>方法重载</strong><ul>\n<li>名字相同，但参数列表不同</li>\n</ul>\n</li>\n<li><strong>命令行传参</strong><ul>\n<li>给main方法传递参数</li>\n</ul>\n</li>\n<li><strong>可变长参数</strong><ul>\n<li><code>...</code></li>\n<li>必须放在最后一个参数</li>\n</ul>\n</li>\n<li><strong>递归</strong></li>\n</ul>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><ul>\n<li><strong>数组举例</strong><ul>\n<li><code>new int[10]</code></li>\n<li><code>{1,2,3}</code></li>\n<li>同一数组内的数据必须相同类型</li>\n</ul>\n</li>\n<li><strong>数组的使用</strong><ul>\n<li>通过下标拿到值</li>\n<li><code>ArrayIndexOfBounds</code></li>\n<li>增强的for循环遍历</li>\n</ul>\n</li>\n<li><strong>二维数组</strong><ul>\n<li><code>new int[][]</code></li>\n</ul>\n</li>\n<li><strong>Array工具类</strong></li>\n<li><strong>排序算法</strong><ul>\n<li>冒泡排序</li>\n<li>选择排序</li>\n<li>插入排序</li>\n<li>快速排序</li>\n<li>归并排序</li>\n<li>希尔排序</li>\n<li>堆排序</li>\n<li>桶排序</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><ul>\n<li><p><strong>何为面向对象</strong></p>\n<ul>\n<li>把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。</li>\n</ul>\n</li>\n<li><p><strong>类与对象</strong></p>\n<ul>\n<li>类是对象的抽象：即模板Class</li>\n<li>对象是类的实例</li>\n</ul>\n</li>\n<li><strong>构造方法</strong><ul>\n<li>构造的重载<ul>\n<li>默认为无参构造</li>\n<li>如果手动定义了一个有参构造就必须再加一个无参构造</li>\n<li>单例模式，需要构造器私有！</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>new对象</strong><ul>\n<li>栈存放引用</li>\n<li>堆存放具体的对象</li>\n</ul>\n</li>\n<li><strong>封装</strong><ul>\n<li>属性私有，即：<code>get</code>、<code>set</code>方法</li>\n</ul>\n</li>\n<li><p><strong>继承</strong></p>\n<ul>\n<li><code>extends</code></li>\n<li><code>Object</code></li>\n<li>子类拥有父类的全部属性</li>\n<li>方法重写</li>\n<li><code>this</code></li>\n<li><code>super</code></li>\n<li>Java是单继承，只可继承一个父类</li>\n</ul>\n</li>\n<li><p><strong>多态</strong></p>\n<ul>\n<li>父类的引用指向子类的对象&nbsp; <code>Person person = new Student();</code></li>\n<li><code>instance of</code>关键，如果匹配，可以进行类型之间的转换</li>\n</ul>\n</li>\n<li><p><strong>修饰符</strong></p>\n<ul>\n<li><code>public</code></li>\n<li><code>protected</code></li>\n<li><code>private</code></li>\n<li><code>static</code></li>\n<li><code>final</code></li>\n<li><code>abstract</code></li>\n</ul>\n</li>\n<li><p><strong>接口</strong></p>\n<ul>\n<li><code>interface</code></li>\n<li>约束：只能定义方法名</li>\n<li>子类实现接口时，必须重写其方法</li>\n<li>只有一个方法的接口叫做函数式接口，可使用<code>lamda</code>表达式进行简化</li>\n<li>接口比抽象类更抽象</li>\n<li>一个类可以实现多个接口</li>\n</ul>\n</li>\n<li><p><strong>内部类</strong></p>\n<ul>\n<li>局部内部类</li>\n<li>静态内部类</li>\n<li>匿名内部类</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><ul>\n<li><p><strong>Throwable</strong></p>\n<ul>\n<li>Exception<ul>\n<li>运行时异常<ul>\n<li><code>1/0</code></li>\n<li><code>ClassNotFound</code></li>\n<li><code>NullPoint</code></li>\n<li><code>UnKonwnType</code></li>\n<li><code>ArrayIndexOutOfBounds</code></li>\n</ul>\n</li>\n<li>检查时异常</li>\n</ul>\n</li>\n<li>Error<ul>\n<li>AWT错误</li>\n<li>JVM错误<ul>\n<li><code>StackOverFlow</code></li>\n<li><code>OutOfMemory</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>五个关键字</strong></p>\n<ul>\n<li><code>try{}</code></li>\n<li><code>catch(){}</code></li>\n<li><code>finally{}</code></li>\n<li><code>throw</code>&nbsp;手动抛出异常</li>\n<li><code>throws</code>&nbsp;方法抛出异常</li>\n</ul>\n</li>\n<li><p><strong>自定义异常</strong></p>\n<ul>\n<li>继承<code>Exception</code>类即可</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"常用类\"><a href=\"#常用类\" class=\"headerlink\" title=\"常用类\"></a>常用类</h2><ul>\n<li><strong>Object类</strong><ul>\n<li><code>hashcode()</code></li>\n<li><code>toString()</code></li>\n<li><code>clone()</code></li>\n<li><code>getClass()</code></li>\n<li><code>notify()</code></li>\n<li><code>wait()</code></li>\n<li><code>equals()</code></li>\n</ul>\n</li>\n<li><strong>Math类</strong><ul>\n<li>常见的数学运算</li>\n</ul>\n</li>\n<li><strong>Random类</strong><ul>\n<li>生成随机数&nbsp;<code>UUID</code></li>\n</ul>\n</li>\n<li><strong>File类</strong><ul>\n<li>文件的增删改查</li>\n</ul>\n</li>\n<li><strong>包装类</strong><ul>\n<li>自动装箱</li>\n<li>自动拆箱</li>\n</ul>\n</li>\n<li><strong>Date类</strong><ul>\n<li><code>Date</code></li>\n<li><code>simpleDateFormat</code>:&nbsp;<code>yyyy-MM-dd HH:mm:ss</code></li>\n<li><code>Calendar</code></li>\n</ul>\n</li>\n<li><strong>String类</strong><ul>\n<li>不可变性final,操作量较少</li>\n</ul>\n</li>\n<li><strong>StringBuffer</strong><ul>\n<li>可变长</li>\n<li><code>append()</code></li>\n<li>多线程数据量较大</li>\n<li>效率低，安全</li>\n</ul>\n</li>\n<li><strong>StringBuilder</strong><ul>\n<li>可变长</li>\n<li>单线程数据量较大</li>\n<li>效率高，不安全</li>\n</ul>\n</li>\n<li><code>String str = &quot;a&quot;+1 + 2</code></li>\n<li><code>String str = &#39;a&#39; + 1 + 2</code></li>\n<li><code>String str = 1+2+&#39;a&#39;</code></li>\n</ul>\n<h2 id=\"集合框架\"><a href=\"#集合框架\" class=\"headerlink\" title=\"集合框架\"></a>集合框架</h2><h3 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h3><ul>\n<li><strong>List</strong><ul>\n<li><code>ArrayList</code><ul>\n<li><code>add()</code></li>\n<li><code>remove()</code></li>\n<li><code>contains()</code></li>\n<li><code>size()</code></li>\n</ul>\n</li>\n<li><code>LinkedList</code><ul>\n<li><code>getFirst()</code></li>\n<li><code>getLast()</code></li>\n<li><code>removeFirst()</code></li>\n<li><code>addFirst()</code></li>\n</ul>\n</li>\n<li>iterator迭代器</li>\n</ul>\n</li>\n<li><strong>Set</strong><ul>\n<li><code>HashSet</code></li>\n<li><code>TreeSet</code><h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3></li>\n<li><code>HashMap</code></li>\n<li><code>TreeMap</code><h3 id=\"Collections工具类\"><a href=\"#Collections工具类\" class=\"headerlink\" title=\"Collections工具类\"></a>Collections工具类</h3><h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3></li>\n</ul>\n</li>\n<li>约束，避免类型转换之间的问题</li>\n</ul>\n<h2 id=\"I-O流\"><a href=\"#I-O流\" class=\"headerlink\" title=\"I/O流\"></a>I/O流</h2><h3 id=\"字节流\"><a href=\"#字节流\" class=\"headerlink\" title=\"字节流\"></a>字节流</h3><ul>\n<li>输出：<code>OutputStream</code></li>\n<li>输入：<code>InputStream</code></li>\n</ul>\n<h3 id=\"字符流\"><a href=\"#字符流\" class=\"headerlink\" title=\"字符流\"></a>字符流</h3><ul>\n<li><strong>Reader</strong></li>\n<li><strong>Wirter</strong></li>\n</ul>\n<h3 id=\"节点流\"><a href=\"#节点流\" class=\"headerlink\" title=\"节点流\"></a>节点流</h3><ul>\n<li><code>CharArrayReader</code>、<code>Wirter</code>、<code>inputstream</code>、<code>outputstream</code></li>\n<li><code>StringReader</code>、<code>Writer</code></li>\n<li><code>pipe</code>、<code>pipedOutputStream</code></li>\n<li><code>File</code></li>\n</ul>\n<h3 id=\"处理流\"><a href=\"#处理流\" class=\"headerlink\" title=\"处理流\"></a>处理流</h3><ul>\n<li><p><strong>buffer</strong></p>\n<ul>\n<li><code>bufferInputStream</code></li>\n<li><code>bufferOutputStream</code></li>\n<li><code>bufferReader</code></li>\n<li><code>bufferWriter</code></li>\n</ul>\n</li>\n<li><p><strong>data</strong></p>\n<ul>\n<li><code>DataInputStream</code></li>\n<li><code>DataOutputStream</code></li>\n</ul>\n</li>\n<li><strong>object流</strong></li>\n<li><strong>转换流</strong><ul>\n<li><code>InputStreamReader</code></li>\n<li><code>OutputStreamWriter</code></li>\n</ul>\n</li>\n<li><strong>Filter</strong><ul>\n<li>四个</li>\n</ul>\n</li>\n<li><strong>print</strong><ul>\n<li><code>PrintWriter</code></li>\n<li><code>PrintStream</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><h3 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h3><ul>\n<li><code>run()</code></li>\n<li><code>Start()</code></li>\n</ul>\n<h3 id=\"线程创建的方式\"><a href=\"#线程创建的方式\" class=\"headerlink\" title=\"线程创建的方式\"></a>线程创建的方式</h3><ul>\n<li><code>Thread</code></li>\n<li><code>Runnable</code></li>\n<li><code>Callable</code></li>\n</ul>\n<h3 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h3><ul>\n<li><code>new Thread(Runnable).start();</code></li>\n</ul>\n<h3 id=\"Lamda表达式\"><a href=\"#Lamda表达式\" class=\"headerlink\" title=\"Lamda表达式\"></a>Lamda表达式</h3><ul>\n<li>函数式编程</li>\n<li>避免内部类定义过多</li>\n<li><code>new Thread(()-&gt;{System.out.printIn();}).start();</code></li>\n</ul>\n<h3 id=\"线程的状态\"><a href=\"#线程的状态\" class=\"headerlink\" title=\"线程的状态\"></a>线程的状态</h3><ul>\n<li><strong>新建态</strong></li>\n<li><strong>就绪态</strong></li>\n<li><strong>运行态</strong></li>\n<li><strong>阻塞态</strong></li>\n<li><strong>死亡态</strong></li>\n</ul>\n<h3 id=\"常用的方法\"><a href=\"#常用的方法\" class=\"headerlink\" title=\"常用的方法\"></a>常用的方法</h3><ul>\n<li><code>sleep()</code></li>\n<li><code>join()</code></li>\n<li><code>yield()</code></li>\n<li><code>isLive()</code></li>\n<li><code>start()</code></li>\n<li><code>setPriority()</code></li>\n<li><code>interrupt()</code></li>\n</ul>\n<h3 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h3><ul>\n<li><strong>多个对象操作同一个资源，并发</strong></li>\n<li><strong>对列+锁</strong></li>\n<li><strong>Synchronized</strong><ul>\n<li>同步方法</li>\n<li>同步代码块（常用）</li>\n<li>锁，第一个线程进来拿到锁，后面的就要排队了，直到这个线程释放锁，后面的线程才能拿到锁进去</li>\n<li>死锁，两个人都抱着对方的锁<ul>\n<li>互斥</li>\n<li>请求与保持</li>\n<li>不剥夺条件</li>\n<li>循环等待条件</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Lock</strong><ul>\n<li><code>ReentrantLock</code><ul>\n<li><code>lock</code></li>\n<li><code>trylock</code></li>\n<li><code>unlock</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程通信\"><a href=\"#线程通信\" class=\"headerlink\" title=\"线程通信\"></a>线程通信</h3><ul>\n<li>缓冲区：消息队列</li>\n<li>标志位：红绿灯</li>\n<li><code>wait()</code></li>\n<li><code>notifyAll()</code></li>\n</ul>\n<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><ul>\n<li><strong>池化技术</strong></li>\n<li><strong>池的大小</strong></li>\n<li><strong>最大连接数</strong></li>\n<li><strong>保持时间</strong></li>\n</ul>\n<h2 id=\"网络编程\"><a href=\"#网络编程\" class=\"headerlink\" title=\"网络编程\"></a>网络编程</h2><ul>\n<li><strong>IP</strong></li>\n<li><strong>端口</strong></li>\n<li><strong>Socket编程</strong></li>\n<li><strong>TCP</strong><ul>\n<li>三次握手</li>\n<li>四次挥手</li>\n<li>面向连接</li>\n</ul>\n</li>\n<li><strong>UDP</strong><ul>\n<li>无连接</li>\n<li>Packet</li>\n</ul>\n</li>\n<li><strong>URL</strong></li>\n<li><strong>初识Tomcat</strong></li>\n<li><strong>聊天通信</strong></li>\n<li><strong>文件上传</strong></li>\n</ul>\n<h2 id=\"GUI\"><a href=\"#GUI\" class=\"headerlink\" title=\"GUI\"></a>GUI</h2><h3 id=\"AWT\"><a href=\"#AWT\" class=\"headerlink\" title=\"AWT\"></a>AWT</h3><ul>\n<li><strong>Frame</strong></li>\n<li><strong>监听事件</strong><ul>\n<li>鼠标</li>\n<li>键盘</li>\n<li>窗口</li>\n<li>动作事件</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Swing\"><a href=\"#Swing\" class=\"headerlink\" title=\"Swing\"></a>Swing</h3><ul>\n<li><strong>文本框</strong></li>\n<li><strong>标签</strong></li>\n<li><strong>按钮</strong></li>\n<li><strong>文本域</strong></li>\n<li><strong>面板</strong></li>\n<li><strong>布局方式</strong></li>\n<li><strong>关闭窗口</strong></li>\n<li><strong>列表</strong></li>\n</ul>\n<h2 id=\"注解和反射\"><a href=\"#注解和反射\" class=\"headerlink\" title=\"注解和反射\"></a>注解和反射</h2><h3 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h3><ul>\n<li><strong>元注解</strong></li>\n<li><strong>内置注解</strong></li>\n<li><strong>自定义注解</strong></li>\n<li><strong>反射读取注解</strong></li>\n</ul>\n<h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><ul>\n<li><strong>Class</strong><ul>\n<li><code>newInstance()</code></li>\n</ul>\n</li>\n<li><strong>类加载机制</strong></li>\n<li><strong>Method</strong><ul>\n<li><code>invoke(person1,&quot;kevin&quot;);</code></li>\n<li>存在重载，需要些参数的类型</li>\n</ul>\n</li>\n<li><strong>Field</strong><ul>\n<li><code>set(person2,&quot;marvin&quot;);</code></li>\n</ul>\n</li>\n<li><strong>Construct</strong><ul>\n<li><code>newInstance()</code></li>\n<li>获取的时候需要传递参数的class类型</li>\n</ul>\n</li>\n<li><strong>破坏私有关键字</strong><ul>\n<li><code>setAccessible(true);</code></li>\n</ul>\n</li>\n<li><strong>性能分析</strong><ul>\n<li>正常&gt;检测关闭的反射&gt;默认的反射</li>\n</ul>\n</li>\n<li>反射获得注解、泛型</li>\n</ul>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "https://peter-pan001.github.io/my-blog/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/",
            "url": "https://peter-pan001.github.io/my-blog/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/",
            "title": "多线程笔记总结",
            "date_published": "2020-10-27T14:03:52.000Z",
            "content_html": "<h1 id=\"JAVA多线程笔记总结\"><a href=\"#JAVA多线程笔记总结\" class=\"headerlink\" title=\"JAVA多线程笔记总结\"></a>JAVA多线程笔记总结</h1><h2 id=\"线程简介\"><a href=\"#线程简介\" class=\"headerlink\" title=\"线程简介\"></a>线程简介</h2><ol>\n<li><p><strong>进程与线程</strong></p>\n<p>| 进程（process）                                              | 线程(Thread)                                                 |<br>| —————————————————————————————— | —————————————————————————————— |<br>| 进程是<strong>程序的一次执行</strong>，是系统进行资源<strong>分配和调度的一个独立单位</strong> | 线程作为资源<strong>调度</strong>的基本单位，<strong>是程序的执行单元，执行路径</strong> |</p>\n</li>\n</ol>\n<ol>\n<li><p><strong>线程的3个基本状态</strong></p>\n<ol>\n<li><p>执行</p>\n</li>\n<li><p>就绪</p>\n</li>\n<li><p>阻塞</p>\n</li>\n</ol>\n</li>\n</ol>\n<ol>\n<li><p><strong>线程的5种基本操作</strong></p>\n<ol>\n<li><p>创建</p>\n</li>\n<li><p>可运行</p>\n</li>\n<li><p>阻塞</p>\n</li>\n<li><p>调度</p>\n</li>\n<li><p>被终止</p>\n</li>\n</ol>\n</li>\n</ol>\n<ol>\n<li><p><strong>线程的两个基本类型</strong></p>\n<ol>\n<li><p><strong>用户级线程</strong> ：管理过程全部由用户程序完成，<strong>操作系统内核心只对进程进行管理。</strong></p>\n</li>\n<li><p><strong>系统级线程</strong>(核心级线程)：<strong>由操作系统内核进行管理</strong>。</p>\n</li>\n</ol>\n</li>\n</ol>\n<ol>\n<li><p><strong>何为多任务？</strong></p>\n<p>生活中有很多例子，如：在开车时打电话吃零食；即一个对象同时进行多项任务。</p>\n</li>\n</ol>\n<ol>\n<li><p><strong>何为多线程？</strong></p>\n<p>在打游戏时，游戏中出现的视频、音频、字幕、震动反馈等都是一个个的线程，在游戏这个应用程序下分支为多个线程，而游戏就是一个进程！</p>\n</li>\n</ol>\n<h2 id=\"Java实现多线程\"><a href=\"#Java实现多线程\" class=\"headerlink\" title=\"Java实现多线程\"></a>Java实现多线程</h2><ul>\n<li><strong>方法一：通过继承Thread类调用线程</strong> </li>\n</ul>\n<ol>\n<li><p><strong>继承Thread类</strong> </p>\n<pre><code class=\"lang-java\">public class MyThread extends Thread {\n        //线程体\n    @Override//重写run方法\n    public void run() {\n        for (int x = 0; x &lt; 200; x++) {\n            System.out.println(x);\n        }\n    }\n\n}\n</code></pre>\n</li>\n</ol>\n<ol>\n<li><p><strong>start()方法启动线程</strong></p>\n<pre><code class=\"lang-java\">public static void main(String[] args) {\n        //main线程\n        //TextThread01该代码的类\n        //创建一个线程对象\n        TextThread01 textThread01 = new TextThread01();\n        //调用start()方法启动线程\n        textThread01.start();\n\n        for (int i = 0; i &lt; 2000; i++) {\n            System.out.println(&quot;打游戏  &quot;+i);\n        }\n    }\n</code></pre>\n</li>\n</ol>\n<ul>\n<li><strong>方法二：实现Runnable接口</strong> </li>\n</ul>\n<ol>\n<li><p>实现Runnable接口</p>\n<pre><code class=\"lang-java\"> public class TextThread03 implements Runnable {\n    @Override\n    public void run() {\n        //run方法线程体\n        for (int i = 0; i &lt; 200; i++) {\n            System.out.println(&quot;正在敲代码---&quot;+i);\n        }\n    }\n</code></pre>\n</li>\n<li><p>在主线程下创建Runnable接口实现类对象 ，并使用new Thread(对象名).start();启动线程</p>\n<pre><code class=\"lang-java\">public static void main(String[] args) {\n        //创建Runnable接口实现类对象\n        TextThread03 thread03 = new TextThread03();\n  //启动方式一：\n//        Thread thread = new Thread();\n//\n//        thread.start();\n //启动方式二：\n        new Thread(thread03).start();\n    }\n</code></pre>\n</li>\n</ol>\n<ul>\n<li><strong>方式三：实现Callable接口，需要返回值类型</strong></li>\n</ul>\n<ol>\n<li><p>实现callable接口，重写call方法</p>\n<pre><code class=\"lang-java\">public class Text_Callable implements Callable&lt;Boolean&gt; {//此处的返回值类型为布尔类型\n    private String url;//网络图片地址\n    private String name;\n\n    public Text_Callable(String url, String name) {\n        this.url = url;\n        this.name = name;\n    }\n\n    @Override\n    public Boolean call() {\n        WebDownloader webDownload = new WebDownloader();\n        webDownload.downloader(url, name);\n        System.out.println(&quot;下载了文件名为&quot; + name + &quot;的文件&quot;);\n        return  true;\n    }\n</code></pre>\n</li>\n<li><p>创建线程对象(在main方法中)</p>\n<pre><code class=\"lang-java\"> Text_Callable t1 = new Text_Callable(&quot;https://pic2.zhimg.com/80/v2-517bd06e7b6fdaec9b9a0b3df525fc29_1440w.jpg&quot;, &quot;1.jpg&quot;);\n        Text_Callable t2 = new Text_Callable(&quot;https://pic3.zhimg.com/80/v2-c9b19e6c66d08934922ed266d71fca5d_720w.jpg&quot;, &quot;2.jpg&quot;);\n        Text_Callable t3 = new Text_Callable(&quot;https://pic4.zhimg.com/80/v2-c5eeefcb0c6c9f86553ace622a7e8329_720w.jpg&quot;, &quot;3.jpg&quot;);\n</code></pre>\n</li>\n<li><p>创建执行服务：创建线程池 </p>\n<pre><code class=\"lang-java\">ExecutorService ser = Executors.newFixedThreadPool(3);\n</code></pre>\n</li>\n<li><p>配合future接口执行服务</p>\n<pre><code class=\"lang-java\\\">Future&lt;Boolean&gt; r1 = ser.submit(t1);\nFuture&lt;Boolean&gt; r2 = ser.submit(t2);\nFuture&lt;Boolean&gt; r3 = ser.submit(t3);\n</code></pre>\n</li>\n<li><p>获取结果</p>\n<pre><code class=\"lang-java\">  boolean rs1 = r1.get();\n  boolean rs2 = r2.get();\n  boolean rs3 = r3.get();\n</code></pre>\n<p>6.关闭服务</p>\n<pre><code class=\"lang-java\"> ser.shutdownNow();\n</code></pre>\n</li>\n</ol>\n<h2 id=\"并发与并行\"><a href=\"#并发与并行\" class=\"headerlink\" title=\"并发与并行\"></a>并发与并行</h2><ul>\n<li><strong>并行：</strong><pre><code>* 并行性是指**同一时刻**发生两个或多个事件\n   * 并行是在不同的实体上的多个事件\n</code></pre></li>\n<li><strong>并发：</strong><pre><code>* 并发性是指**同一时间间隔内**发生两个或多个事件\n   * 并发是**同一实体**上的多个事件\n</code></pre></li>\n</ul>\n<h2 id=\"Thread类源码分析\"><a href=\"#Thread类源码分析\" class=\"headerlink\" title=\"Thread类源码分析\"></a>Thread类源码分析</h2><ol>\n<li><p>设置线程名</p>\n<pre><code class=\"lang-java\">Thread.currentThread().getName()\n</code></pre>\n</li>\n<li><p>守护线程  </p>\n<pre><code class=\"lang-java\">thread.setDaemon(true);//默认为false，表示用户线程\n\n        thread.start();//启动守护线程\n\n        new Thread(you).start();//启动用户线程\n</code></pre>\n</li>\n<li><p>优先级线程</p>\n<p>调用Thread.currentThread().getPriority()获得优先级线程的级别（int）</p>\n<p>创建MyPriority实现runnable接口</p>\n<pre><code class=\"lang-java\">class MyPriority implements Runnable{\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+Thread.currentThread().getPriority());\n    }\n}\n</code></pre>\n<p>new一个MyPriority对象，创建线程</p>\n<pre><code class=\"lang-java\">MyPriority myPriority = new MyPriority();\nThread t2 = new Thread(myPriority);\n</code></pre>\n<p>先设置优先级再启动线程</p>\n<pre><code class=\"lang-java\">t2.setPriority(1);//线程优先级范围1-10\n        t2.start();\n</code></pre>\n</li>\n<li><p>线程生命周期</p>\n<ul>\n<li><p>线程休眠(Thread.sleep())</p>\n<p>调用sleep方法会进入计时等待状态，等时间到了，<strong>进入的是就绪状态而并非是运行状态</strong>！</p>\n<pre><code class=\"lang-java\">//模拟延时\n           try {\n               Thread.sleep(200);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n</code></pre>\n</li>\n<li><p>线程礼让(Thread.yield())</p>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>让当前执行的线程执行但不阻塞，若让CPU重新调度，不一定会礼让</p>\n<p>  此时线程由<strong>运行态变为就绪态</strong></p>\n<pre><code class=\"lang-java\">  public class TextYield {\n      public static void main(String[] args) {\n          MyYield myYield = new MyYield();\n          new Thread(myYield,&quot;a&quot;).start();//线程a\n\n          new Thread(myYield,&quot;b&quot;).start();//线程b\n      }\n  }\n  class MyYield implements Runnable{\n      @Override\n      public void run() {\n          System.out.println(Thread.currentThread().getName()+&quot;线程开始执行&quot;);\n          Thread.yield();//线程礼让\n          System.out.println(Thread.currentThread().getName()+&quot;线程停止执行&quot;);\n      }\n  }\n</code></pre>\n</li>\n</ul>\n<ul>\n<li><p>线程霸占(Thread.join())</p>\n<ul>\n<li>java合并线程（即插队），其他线程阻塞，调用join方法，会等待该线程执行完毕后再执行别的线程</li>\n</ul>\n<pre><code class=\"lang-java\">public class TextJoin implements Runnable {\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 200; i++) {\n            System.out.println(&quot;线程vip来了&quot;+i);\n        }\n    }\n    //vip线程霸占主线程\n    public static void main(String[] args) throws InterruptedException{\n        //main线程\n        TextJoin textJoin = new TextJoin();\n        Thread thread = new Thread(textJoin);\n        thread.start();\n\n        for (int i = 0; i &lt; 200; i++) {\n            if(i == 100){\n                thread.join();//插队\n            }\n            System.out.println(&quot;main&quot;+i);\n        }\n    }\n}\n</code></pre>\n</li>\n<li><p>interrupt方法</p>\n</li>\n</ul>\n<ul>\n<li><p>我们一般使用的是interrupt来<strong>请求终止线程</strong>~</p>\n<ul>\n<li>要注意的是：interrupt<strong>不会真正停止</strong>一个线程，它仅仅是给这个线程发了一个信号告诉它，它应该要结束了(明白这一点非常重要！)</li>\n<li>也就是说：Java设计者实际上是<strong>想线程自己来终止</strong>，通过上面的<strong>信号</strong>，就可以判断处理什么业务了。</li>\n<li>具体到底中断还是继续运行，应该<strong>由被通知的线程自己处理</strong></li>\n</ul>\n<pre><code class=\"lang-java\">Thread t1 = new Thread( new Runnable(){\n    public void run(){\n        // 若未发生中断，就正常执行任务\n        while(!Thread.currentThread.isInterrupted()){\n            // 正常任务代码……\n        }\n        // 中断的处理代码……\n        doSomething();\n    }\n} ).start();\n</code></pre>\n</li>\n</ul>\n<h2 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h2><h3 id=\"同步方法\"><a href=\"#同步方法\" class=\"headerlink\" title=\"同步方法\"></a>同步方法</h3><pre><code class=\"lang-java\">public synchronized void method(int args){}\n</code></pre>\n<ul>\n<li><code>synchronized</code>方法都必须获得该方法的对象的锁才能执行，否则线程会出现阻塞</li>\n<li>方法一旦执行就会独占该锁，指导该方法返回才释放锁</li>\n</ul>\n<h3 id=\"同步块\"><a href=\"#同步块\" class=\"headerlink\" title=\"同步块\"></a>同步块</h3><pre><code class=\"lang-java\">synchronized (obj){}\n</code></pre>\n<ul>\n<li>obj称为同步监视器</li>\n<li>obj可以是任何对象但推荐使用共享资源作为同步监视器</li>\n</ul>\n<h2 id=\"死锁（DeadLock）\"><a href=\"#死锁（DeadLock）\" class=\"headerlink\" title=\"死锁（DeadLock）\"></a>死锁（DeadLock）</h2><p>造成死锁的原因可以<strong>概括</strong>成三句话：</p>\n<ul>\n<li>当前线程<strong>拥有其他线程需要的</strong>资源</li>\n<li>当前线程<strong>等待其他线程已拥有</strong>的资源</li>\n<li><strong>都不放弃</strong>自己拥有的资源</li>\n</ul>\n<h3 id=\"1-1-锁顺序死锁\"><a href=\"#1-1-锁顺序死锁\" class=\"headerlink\" title=\"1.1 锁顺序死锁\"></a>1.1 锁顺序死锁</h3><pre><code class=\"lang-java\"> Makeup(int choice,String girlname){\n        this.choice=choice;\n        this.girlname=girlname;\n    }\n    @Override\n    public void run() {\n        //化妆\n        try {\n            makeup();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    //化妆：互相持有对方的锁，就是需要拿到对方的资源\n    private void makeup() throws InterruptedException {\n        if (choice == 0){\n            synchronized (lipstick){\n                System.out.println(this.girlname+&quot;获得口红的锁&quot;);\n                Thread.sleep(1000);\n                synchronized (mirror){\n                    System.out.println(this.girlname+&quot;获得镜子的锁&quot;);\n                }\n            }\n        }else {\n            synchronized (mirror){\n                System.out.println(this.girlname+&quot;获得镜子的锁&quot;);\n                Thread.sleep(2000);\n                synchronized (lipstick){\n                    System.out.println(this.girlname+&quot;获得口红的锁&quot;);\n                }\n            }\n        }\n    }\n</code></pre>\n<h3 id=\"1-2-避免死锁的方法\"><a href=\"#1-2-避免死锁的方法\" class=\"headerlink\" title=\"1.2 避免死锁的方法\"></a>1.2 避免死锁的方法</h3><p>避免死锁可以概括成三种方法：</p>\n<ul>\n<li><strong>固定加锁的顺序</strong>(针对锁顺序死锁)</li>\n<li><strong>开放调用</strong>(针对对象之间协作造成的死锁)</li>\n<li><strong>使用定时锁</strong>—&gt;<code>tryLock()</code><ul>\n<li>如果等待获取锁时间超时，则<strong>抛出异常而不是一直等待</strong>！</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-3线程池\"><a href=\"#1-3线程池\" class=\"headerlink\" title=\"1.3线程池\"></a>1.3线程池</h3><p>线程池可以看做是<strong>线程的集合</strong>。在没有任务时线程处于空闲状态，当请求到来：线程池给这个请求分配一个空闲的线程，任务完成后回到线程池中等待下次任务<strong>(而不是销毁)</strong>。这样就<strong>实现了线程的重用</strong>。</p>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "https://peter-pan001.github.io/my-blog/Java/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/",
            "url": "https://peter-pan001.github.io/my-blog/Java/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/",
            "title": "类与对象",
            "date_published": "2020-10-25T14:01:29.000Z",
            "content_html": "<h2 id=\"什么是类？\"><a href=\"#什么是类？\" class=\"headerlink\" title=\"什么是类？\"></a>什么是类？</h2><ul>\n<li><strong>类</strong>在面向对象编程中是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。</li>\n<li>类有接口和结构。接口描述了如何通过方法与类及其实例互操作，而结构描述了一个实例中数据如何划分为多个属性。</li>\n<li>类是与某个层[注 1]的对象的最具体的类型。类还可以有运行时表示形式（元对象），它为操作与类相关的元数据提供了运行时支持。</li>\n</ul>\n<h2 id=\"回到现实来说，类究竟是什么？\"><a href=\"#回到现实来说，类究竟是什么？\" class=\"headerlink\" title=\"回到现实来说，类究竟是什么？\"></a>回到现实来说，类究竟是什么？</h2><ul>\n<li>在日常生活中，类无处不在，它是一种事物的原型(arcgetype)。对所有的动物来说，可以称为是一个类型，我们简称为“动物类”。</li>\n</ul>\n<h2 id=\"面向对象是什么？\"><a href=\"#面向对象是什么？\" class=\"headerlink\" title=\"面向对象是什么？\"></a>面向对象是什么？</h2><ul>\n<li><strong>面向对象程序设计</strong>（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</li>\n<li>面向对象程序设计中的对<strong>每一个象都应该能够接受数据、处理数据并将数据传达给其它对象</strong>，因此它们都可以被看作一个小型的“机器”，即对象。目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。</li>\n</ul>\n<h2 id=\"在Java中把类和对象联系起来\"><a href=\"#在Java中把类和对象联系起来\" class=\"headerlink\" title=\"在Java中把类和对象联系起来\"></a>在Java中把类和对象联系起来</h2><ul>\n<li>类（Class）：定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。</li>\n<li>对象：是类的实例。<ul>\n<li><strong>总而言之，类是抽象的，而对象是具体的</strong></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"类的创建\"><a href=\"#类的创建\" class=\"headerlink\" title=\"类的创建\"></a>类的创建</h2><ul>\n<li>我们在使用编译器时，创建的每一个<code>.java</code>文件，实际上就是一个类，可以这样说，创建一个java文件，就意味着创建了一个类，而这个刚创建的类是抽象的，里面什么都没有，此时，需要你通过创建对象来把这个类给实例化。</li>\n</ul>\n<h2 id=\"使用对象的步骤\"><a href=\"#使用对象的步骤\" class=\"headerlink\" title=\"使用对象的步骤\"></a>使用对象的步骤</h2><ol>\n<li><p>首先创建对象：</p>\n<ul>\n<li>语法：<ul>\n<li>类名 &nbsp;对象名 &nbsp;= &nbsp;new &nbsp;类名();</li>\n</ul>\n</li>\n<li>例如：<br><code>Car  sportCar = new Car();</code></li>\n</ul>\n</li>\n<li><p>使用对象：</p>\n<ul>\n<li>引用对象的属性：对象名<code>.</code>属性<code>;</code>    </li>\n<li>引用对象的方法：对象名<code>.</code>方法名（）<code>;</code></li>\n<li>例如：<pre><code class=\"lang-java\">phone.voice =5;\nphone.sendMessage();\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><strong>注意：一个java文件可以有多个类，但只能有一个<code>public</code>修饰的类</strong></li>\n</ul>\n<h2 id=\"成员变量与局部变量的区别\"><a href=\"#成员变量与局部变量的区别\" class=\"headerlink\" title=\"成员变量与局部变量的区别\"></a>成员变量与局部变量的区别</h2><ol>\n<li>作用域不同<ul>\n<li>局部变量的作用域仅限于定义它的方法中</li>\n<li>成员变量的作用域在整个类的内部</li>\n</ul>\n</li>\n<li>初始值不同<ul>\n<li>Java会给成员变量一个初始值</li>\n<li>但不会给局部变量赋予初始值</li>\n</ul>\n</li>\n<li>在同一个方法中，不允许有同名的局部变量</li>\n<li>在不同的方法中，可以有同名的局部变量</li>\n<li>两类变量同名时，局部变量具有更高的优先级</li>\n</ol>\n<h2 id=\"什么是构造方法？\"><a href=\"#什么是构造方法？\" class=\"headerlink\" title=\"什么是构造方法？\"></a>什么是构造方法？</h2><ul>\n<li><strong>定义：</strong>构造器跟一般的实例方法十分相似；但是与其它方法不同，构造器没有返回类型，不会被继承，且不会有范围修饰符。构造器的函数名称一般与它所属的类的名称相同。</li>\n<li><strong>特性：</strong><ol>\n<li>使用<code>new</code>+构造方法，创建一个新的对象</li>\n<li>构造方法是定义在JAVA类的一个用来初始化对象的方法<ul>\n<li>构造方法与类同名且没有返回值</li>\n</ul>\n</li>\n<li>当没有指定构造方法时，系统会自动添加无参的构造方法</li>\n<li>当有指定构造方法，无论是有参、无参的构造方法，都不会自动添加无参的构造方法</li>\n<li>构造方法的重载：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择相应的方法 </li>\n</ol>\n</li>\n</ul>\n<h2 id=\"面向对象的内存分析\"><a href=\"#面向对象的内存分析\" class=\"headerlink\" title=\"面向对象的内存分析\"></a>面向对象的内存分析</h2><ul>\n<li>在Java虚拟机中的内存区域划分<ul>\n<li>栈（stack）</li>\n<li>堆（heap）</li>\n<li>方法区（methodarea）实际存在于堆之中</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><ul>\n<li>描述方法执行的内存模型</li>\n<li>方法被调用创建一个栈帧</li>\n<li>栈属于<strong>线程私有</strong>，不能实现线程间共享</li>\n<li>由系统自动分配，速度快（物理上是连续的内存空间）</li>\n</ul>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><ul>\n<li>用于存储创建好的对象和数组</li>\n<li>JVM只有一个堆，<strong>所有线程共享</strong></li>\n<li>物理上不是连续的内存空间，存在着速度慢的问题，但存储更加灵活！</li>\n</ul>\n<h3 id=\"方法区（静态区）\"><a href=\"#方法区（静态区）\" class=\"headerlink\" title=\"方法区（静态区）\"></a>方法区（静态区）</h3><ul>\n<li>用于存放程序中永远不变或唯一的内容<ul>\n<li>例如：类信息、class对象、静态变量等</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"静态方法（用static修饰方法）\"><a href=\"#静态方法（用static修饰方法）\" class=\"headerlink\" title=\"静态方法（用static修饰方法）\"></a>静态方法（用static修饰方法）</h2><ul>\n<li>静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态方法</li>\n<li>在普通成员方法中，则可以直接访问同类的非静态变量和静态变量</li>\n<li>静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法</li>\n</ul>\n<h2 id=\"static关键字\"><a href=\"#static关键字\" class=\"headerlink\" title=\"static关键字\"></a>static关键字</h2><ul>\n<li><p>定义：</p>\n<ul>\n<li>Java中被<code>static</code>修饰的成员成为静态成员或类成员。它属于整个类所有，而不是归某个对象所有，即被类的所有对象所共享静态成员可以使用类名直接访问，也可以使用对象名进行访问</li>\n</ul>\n</li>\n<li><p>注意：</p>\n<ul>\n<li><code>static</code>修饰的成员变量和方法，从属于类！！！</li>\n<li><p>普通变量和方法从属于对象！！！</p>\n<p><img data-src=\"https://i.loli.net/2020/10/22/xipTHVwdOJFGBcK.png\" alt=\"methodstatic.png\"></p>\n</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "https://peter-pan001.github.io/my-blog/Java/Java%E8%AF%AD%E5%8F%A5/",
            "url": "https://peter-pan001.github.io/my-blog/Java/Java%E8%AF%AD%E5%8F%A5/",
            "title": "Java语句",
            "date_published": "2020-10-25T12:51:19.000Z",
            "content_html": "<h2 id=\"Java-输入语句\"><a href=\"#Java-输入语句\" class=\"headerlink\" title=\"Java 输入语句\"></a>Java 输入语句</h2><h3 id=\"1-1-使用Scanner类\"><a href=\"#1-1-使用Scanner类\" class=\"headerlink\" title=\"1.1 使用Scanner类\"></a>1.1 使用Scanner类</h3><ul>\n<li>步骤：<ul>\n<li>使用<code>java.util</code>包，即<code>import java.util.*;</code></li>\n<li>构造Scanner类对象，它属于标准输入流<code>System.in</code><ul>\n<li>即：<pre><code class=\"lang-java\">Scanner s = new Scanner(System.in);\n</code></pre>\n</li>\n</ul>\n</li>\n<li>常用的<code>next()</code>方法系列：<ul>\n<li><code>next()</code> &nbsp;输入字符串（以空格作为分隔符）</li>\n<li><code>nextInt()</code> &nbsp;输入整数</li>\n<li><code>nextLine()</code> &nbsp;输入字符串</li>\n<li><code>nextDouble()</code> &nbsp;输入双精度数</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-使用java-io-BufferReader和java-io-InputStreamReader\"><a href=\"#1-2-使用java-io-BufferReader和java-io-InputStreamReader\" class=\"headerlink\" title=\"1.2 使用java.io.BufferReader和java.io.InputStreamReader\"></a>1.2 使用java.io.BufferReader和java.io.InputStreamReader</h3><ul>\n<li><ol>\n<li>导入io包<pre><code class=\"lang-java\">import java.io.*;\n</code></pre>\n</li>\n</ol>\n</li>\n<li><ol>\n<li>构造<code>BufferReader</code>类对象<pre><code class=\"lang-java\">Bufferreader br = new BufferReader(new InputStreamReader)(System.in);\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"Java输出语句\"><a href=\"#Java输出语句\" class=\"headerlink\" title=\"Java输出语句\"></a>Java输出语句</h2><ul>\n<li>分类：<ul>\n<li><code>System.out.println();</code>  换行打印</li>\n<li><code>System.out.print();</code> 不换行打印</li>\n<li><code>System.out.write(1121);</code> 字节输出 </li>\n<li><code>System.out.printf(&quot;%+8.3f\\n&quot;,3.14);</code> 按格式输出</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-1-换行打印\"><a href=\"#2-1-换行打印\" class=\"headerlink\" title=\"2.1 换行打印\"></a>2.1 换行打印</h3><ul>\n<li><code>System.out.println();</code> &nbsp;是最常见的输出语句，把（）里的内容转换为字符串输出，并且换行<ul>\n<li>若输出的是一个基本数据类型，则转换为字符串</li>\n<li>若输出的是对象，则会自动调用对象的<code>toString();</code>方法</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-2-按格式输出\"><a href=\"#2-2-按格式输出\" class=\"headerlink\" title=\"2.2 按格式输出\"></a>2.2 按格式输出</h3><ul>\n<li><code>System.out.printf(&quot;%+8.3f\\n&quot;,3.14);</code> &nbsp;通过格式化文本和参数列表输出</li>\n</ul>\n<h2 id=\"Java条件语句\"><a href=\"#Java条件语句\" class=\"headerlink\" title=\"Java条件语句\"></a>Java条件语句</h2><h3 id=\"3-1-if语句\"><a href=\"#3-1-if语句\" class=\"headerlink\" title=\"3.1 if语句\"></a>3.1 if语句</h3><h4 id=\"3-1-1-最普通的写法：\"><a href=\"#3-1-1-最普通的写法：\" class=\"headerlink\" title=\"3.1.1 最普通的写法：\"></a>3.1.1 最普通的写法：</h4><pre><code class=\"lang-java\">  if(条件表达式){\n      条件执行的语句;\n  }\n</code></pre>\n<h4 id=\"3-1-2-if-else写法：\"><a href=\"#3-1-2-if-else写法：\" class=\"headerlink\" title=\"3.1.2 if....else写法：\"></a>3.1.2 <code>if....else</code>写法：</h4><pre><code class=\"lang-java\">  if(条件表达式){\n      条件执行的语句;\n  } else{\n      执行语句;\n  }\n</code></pre>\n<h4 id=\"3-1-3-多重if\"><a href=\"#3-1-3-多重if\" class=\"headerlink\" title=\"3.1.3 多重if\"></a>3.1.3 多重if</h4><pre><code class=\"lang-java\">  if(条件1){\n      代码块1;\n  }else if(条件2){\n      代码块2;\n  }else if(条件3){\n      代码块3;\n  }\n</code></pre>\n<h4 id=\"3-1-4-嵌套if\"><a href=\"#3-1-4-嵌套if\" class=\"headerlink\" title=\"3.1.4 嵌套if\"></a>3.1.4 嵌套if</h4><pre><code class=\"lang-java\">  if(条件1){\n      if(条件2){\n          代码块1;\n      }else{\n          代码块2;\n      }\n  }else{\n      代码块3;\n  }\n</code></pre>\n<h3 id=\"3-2-switch语句\"><a href=\"#3-2-switch语句\" class=\"headerlink\" title=\"3.2 switch语句\"></a>3.2 switch语句</h3><ul>\n<li>语法：<pre><code class=\"lang-java\">switch(表达式){\n    case 值1:\n      执行的代码块1;\n      break;\n    case 值2:\n      执行的代码块2;\n      break;  \n   default:\n      默认的执行代码;   \n}\n</code></pre>\n</li>\n</ul>\n<h3 id=\"3-3-while语句\"><a href=\"#3-3-while语句\" class=\"headerlink\" title=\"3.3 while语句\"></a>3.3 while语句</h3><h4 id=\"3-3-1-基本写法\"><a href=\"#3-3-1-基本写法\" class=\"headerlink\" title=\"3.3.1 基本写法\"></a>3.3.1 基本写法</h4><pre><code>```java\nwhile(判断条件){\n    循环语句;\n}\n```\n</code></pre><ul>\n<li>先判断，后执行<h4 id=\"3-3-2-do-while\"><a href=\"#3-3-2-do-while\" class=\"headerlink\" title=\"3.3.2 do-while\"></a>3.3.2 do-while</h4><pre><code class=\"lang-java\">do{\n   循环语句;\n}while(判断条件);\n</code></pre>\n<ul>\n<li>先执行，后判断</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-4-for语句\"><a href=\"#3-4-for语句\" class=\"headerlink\" title=\"3.4 for语句\"></a>3.4 for语句</h3><ul>\n<li>语法：<pre><code class=\"lang-java\">for(循环变量初始化;循环条件;循环变量变化){\n    循环语句;\n}\n</code></pre>\n<h3 id=\"3-5-braek语句\"><a href=\"#3-5-braek语句\" class=\"headerlink\" title=\"3.5 braek语句\"></a>3.5 braek语句</h3></li>\n<li>语法：<pre><code class=\"lang-java\">if(条件){\n    执行操作语句;\n    break;//退出此循环，执行循环外的代码\n}\n</code></pre>\n<h3 id=\"3-6-continue语句\"><a href=\"#3-6-continue语句\" class=\"headerlink\" title=\"3.6 continue语句\"></a>3.6 continue语句</h3></li>\n<li>语法：<pre><code class=\"lang-java\">if(条件){\n    执行操作;\n    continue;//通过continue结束本次循环，进行下一次循环\n}\n</code></pre>\n</li>\n</ul>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "https://peter-pan001.github.io/my-blog/Java/Java%E7%9A%84%E4%B8%80%E4%BA%9B%E7%B1%BB/",
            "url": "https://peter-pan001.github.io/my-blog/Java/Java%E7%9A%84%E4%B8%80%E4%BA%9B%E7%B1%BB/",
            "title": "Java的一些类",
            "date_published": "2020-10-25T12:50:18.000Z",
            "content_html": "<h2 id=\"Java的一些类\"><a href=\"#Java的一些类\" class=\"headerlink\" title=\"Java的一些类\"></a>Java的一些类</h2><h3 id=\"StringBuilder和StringBuffer的使用\"><a href=\"#StringBuilder和StringBuffer的使用\" class=\"headerlink\" title=\"StringBuilder和StringBuffer的使用\"></a>StringBuilder和StringBuffer的使用</h3><ul>\n<li><p>这两个方法的基本解释：</p>\n<ul>\n<li><code>StringBuilder</code>:线程不安全，效率高</li>\n<li><code>StringBuffer</code>:线程安全，效率低</li>\n</ul>\n</li>\n<li><p>实例：</p>\n<pre><code class=\"lang-java\">StringBuilder s = new StringBuilder();//初始长度为16\nStringBuider s1 = new StringBuilder(32);//初始length=32 \ns.append();\ns.delete(int start,int end);\n</code></pre>\n<h3 id=\"StringBuilder类的常用方法\"><a href=\"#StringBuilder类的常用方法\" class=\"headerlink\" title=\"StringBuilder类的常用方法\"></a>StringBuilder类的常用方法</h3><p>| 类名 | 方法名  | 解释 |<br>|:——:|:———:|:——:|<br>|StringBuilder|append(参数)|追加内容到当前<code>StringBuilder</code>对象的末尾|<br>|StringBuilder|insert(位置，参数)|将内容插入到<code>StringBuilder</code>对象的指定位置|<br>|String|toString()|将<code>StringBuilder</code>对象转换为<code>String</code>对象|<br>|int | length()|获取字符串长度|</p>\n</li>\n</ul>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><h4 id=\"一、子串\"><a href=\"#一、子串\" class=\"headerlink\" title=\"一、子串\"></a>一、子串</h4><ul>\n<li>通过<code>String</code>类中的<code>substring</code>方法从一个字符串中提取一个子串</li>\n<li>例如：<pre><code class=\"lang-java\">String s = &quot;Hello&quot;;\nString t = s.substring(0,3);//substring方法用来计算子串的长度，（0，3）表示要复制从0-3的字符，即H、e、l\n</code></pre>\n<h4 id=\"二、拼接\"><a href=\"#二、拼接\" class=\"headerlink\" title=\"二、拼接\"></a>二、拼接</h4></li>\n<li>通过使用<code>+</code>实现</li>\n<li>常用方法：<pre><code class=\"lang-java\">  String player = &quot;vango&quot;;\n  String project = &quot;sunflower&quot;;\n  String message = player + project;\n</code></pre>\n</li>\n<li>字符串与一个非字符串的值进行拼接，后者变成字符串</li>\n<li>可以与输出语句一起使用：<ul>\n<li><code>System.out.println(&quot;result:&quot;+answer);</code></li>\n</ul>\n</li>\n<li>多个字符串放在一起，使用<code>join</code>静态方法<pre><code class=\"lang-java\">String all = String.join(&quot;/&quot;,&quot;S&quot;,&quot;M&quot;,&quot;L&quot;);\n//打印结果： all = “S/M/L”;\n</code></pre>\n</li>\n</ul>\n<h4 id=\"三、不可变字符串\"><a href=\"#三、不可变字符串\" class=\"headerlink\" title=\"三、不可变字符串\"></a>三、不可变字符串</h4><ul>\n<li><code>String</code>类没有通过修改字符串的方法，修改方法为：提取加拼接<ul>\n<li>例如：<pre><code class=\"lang-java\">String s = &quot;Hello&quot;;\ns = s.substring(0,3)+&quot;p!&quot;;\n//  此时 s= help!\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"四、检查字符串是否相等\"><a href=\"#四、检查字符串是否相等\" class=\"headerlink\" title=\"四、检查字符串是否相等\"></a>四、检查字符串是否相等</h4><ul>\n<li>方法：<code>s.equals(t)</code><ul>\n<li>s和t都为字符串，该方法的逻辑是：若s=t ,则输出<code>true</code>，否则，输出<code>false</code></li>\n<li>s可为值，也可以为名称</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"五、空串和NUll串\"><a href=\"#五、空串和NUll串\" class=\"headerlink\" title=\"五、空串和NUll串\"></a>五、空串和NUll串</h4><ul>\n<li>空串就是长度为0的字符串,占用内存</li>\n<li>null是空引用，表示一个对象的值，没有分配内存，调用null的字符串的方法会抛出空指针异常。</li>\n<li><p>空串的表示:</p>\n<pre><code class=\"lang-java\">if(str.length()== 0 ){\n\n} \n//或者\nif(str.equals(&quot;&quot;)){\n\n}\n</code></pre>\n</li>\n<li><p>null串表示：</p>\n<pre><code class=\"lang-java\">if(str == null){\n\n}\n</code></pre>\n</li>\n<li><p>既不是空串，也不是null：</p>\n<pre><code class=\"lang-java\">if(str != null &amp;&amp;str.length()){\n\n}\n</code></pre>\n</li>\n</ul>\n<h4 id=\"六、注意的点\"><a href=\"#六、注意的点\" class=\"headerlink\" title=\"六、注意的点\"></a>六、注意的点</h4><ul>\n<li>字符串<code>str</code>中字符的索引从0开始，范围从0到<code>str.length()</code>-1</li>\n<li>使用<code>indexOf</code>进行字符或字符串查找时，如果匹配返回位置索引，如果没有匹配结果，返回-1</li>\n<li>使用<code>substring(beginIndex,endIndex)</code>进行字符串提取时，包括<code>beginIndex</code>位置的字符，不包括<code>endIndex</code>位置的字符</li>\n</ul>\n<h3 id=\"重写与重载（-Override和-Overload）\"><a href=\"#重写与重载（-Override和-Overload）\" class=\"headerlink\" title=\"重写与重载（@Override和@Overload）\"></a>重写与重载（@Override和@Overload）</h3><ul>\n<li>重写———存在于继承体系中，子类实现父类方法声明的一致相同方法<ul>\n<li>访问权限：子类方法<code>&gt;=</code>父类方法</li>\n<li>返回类型：之类方法的返回类型为父类方法返回类型或子类型</li>\n</ul>\n</li>\n<li>重载———存在于同一个类，方法存在且方法名相同，但参数类型、个数、顺序至少一个不同<ul>\n<li>只有返回值不同的,不叫重载!!!</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Java包装类（Wrapper-Class）\"><a href=\"#Java包装类（Wrapper-Class）\" class=\"headerlink\" title=\"Java包装类（Wrapper Class）\"></a>Java包装类（Wrapper Class）</h3><ul>\n<li><p>包装类就是讲基本类型数据转化为对象，即八种基本类型对应八种包装类<br><img data-src=\"https://i.loli.net/2020/10/22/RkB5PiTptcb4SWd.png\" alt=\"wrapperclass.png\"></p>\n</li>\n<li><p><strong>自动装箱与自动拆箱</strong></p>\n<ul>\n<li><strong>自动装箱（auto-boxing）</strong><ul>\n<li>基本类型自动封装到它相同的包装类里<pre><code class=\"lang-java\">Integer i = 100;\n//本质上，编译器编译时为我们提供了以下代码：\nInteger i = nwe Integer(100);\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>自动拆箱（unboxing）</strong><ul>\n<li>包装类对象自动转换为基本类型<pre><code class=\"lang-java\">int a = new Integer(100);\n//本质上：\nint a = new integer(100).intValue();\n</code></pre>\n</li>\n</ul>\n</li>\n<li>特别的：<br>```java<br>Integer d1 = -129;<br>Integer d2 = -129;<br>System.out.println(d1==d2);<br>//输出的是false，因为在[-128,127]之间的数，按照基本类型处理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Java中基本类型和字符串之间的转换\"><a href=\"#Java中基本类型和字符串之间的转换\" class=\"headerlink\" title=\"Java中基本类型和字符串之间的转换\"></a>Java中基本类型和字符串之间的转换</h3><ul>\n<li><p>基本类型转字符串</p>\n<p><img data-src=\"https://i.loli.net/2020/10/22/uWZvGMkjOQDiBJa.png\" alt=\"switch001.png\"></p>\n</li>\n<li>实例：<pre><code class=\"lang-java\">int c = 10;\nString str1 = Integer.toString(c);\nString str2 = String.valueOf(c);\nString str3 = c+ &quot; &quot;;\n</code></pre>\n</li>\n<li><p>字符串转基本类型</p>\n<p><img data-src=\"https://i.loli.net/2020/10/22/BWrCxUR4ckYzKqi.png\" alt=\"switch002.png\"></p>\n</li>\n<li>实例：<pre><code class=\"lang-java\">String str = &quot;8&quot;;\nint d = Integer.parseInt(str);\nint e = Integer.valueOf(str);\n</code></pre>\n</li>\n</ul>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "https://peter-pan001.github.io/my-blog/Java/Java%E5%B0%81%E8%A3%85/",
            "url": "https://peter-pan001.github.io/my-blog/Java/Java%E5%B0%81%E8%A3%85/",
            "title": "Java封装",
            "date_published": "2020-10-22T14:53:14.000Z",
            "content_html": "<h2 id=\"封装的需求\"><a href=\"#封装的需求\" class=\"headerlink\" title=\"封装的需求\"></a>封装的需求</h2><ul>\n<li>程序设计在追求“高内聚，低耦合”的特点<ul>\n<li>所谓“高内聚”，即是封装代码细节，提高可维护性</li>\n<li>所谓“低耦合”，即是简化外部调用，便于使用者使用</li>\n</ul>\n</li>\n<li>这样一来，提高了代码的安全性和复用性<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2></li>\n<li>将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来<strong>实现对隐藏信息的操作和访问</strong></li>\n</ul>\n<h2 id=\"封装的好处\"><a href=\"#封装的好处\" class=\"headerlink\" title=\"封装的好处\"></a>封装的好处</h2><ul>\n<li>a.只能通过规定的方法访问数据</li>\n<li>b.隐藏类的实例细节，方便修改和实现</li>\n<li>c.适当的封装，可以将对象使用接口的程序实现部分隐藏起来，不让用户看到，同时确保用户无法任意更改对象内部的重要资料，增强代码安全性</li>\n</ul>\n<p><img data-src=\"https://i.loli.net/2020/10/22/In3jwPMrUOl6L2s.png\" alt=\"fengzhuangstep.png\"></p>\n<h2 id=\"Java的访问修饰符\"><a href=\"#Java的访问修饰符\" class=\"headerlink\" title=\"Java的访问修饰符\"></a>Java的访问修饰符</h2><ul>\n<li>java的访问修饰符包括<code>private</code>、<code>default</code>、<code>protected</code>、<code>public</code><br>| 访问修饰符 | 本类  |  同包   |  子类  |  所有类|<br>| :———-:| :———-:| :———-:| :———-:| :———-:|<br>|private| √||||<br>|default|√|√|||<br>|protected|√|√|√||<br>|public|√|√|√|√|</li>\n<li>对属性一律<code>private</code>私有化</li>\n<li>普通类使用<code>public</code></li>\n</ul>\n<h2 id=\"This关键字\"><a href=\"#This关键字\" class=\"headerlink\" title=\"This关键字\"></a>This关键字</h2><blockquote>\n<p>This 也被成为创建好对象的地址,但不可用于静态方法</p>\n<ul>\n<li>使用语法：<pre><code class=\"lang-java\">public class TextThis{\n   int a,b,c;\n   TextThis(int a,int b){\n      this.a=a;\n      this.b=b;\n   }\n}\n</code></pre>\n<ul>\n<li><code>this.</code>属性名，表示操作当前对象的属性</li>\n<li><code>this.</code>方法，表示调用当前对象的方法</li>\n<li>我们在封装对象的属性时，经常会用到<code>this</code>关键字</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "https://peter-pan001.github.io/my-blog/Java/Java%E5%A4%9A%E6%80%81/",
            "url": "https://peter-pan001.github.io/my-blog/Java/Java%E5%A4%9A%E6%80%81/",
            "title": "Java多态",
            "date_published": "2020-10-22T14:53:14.000Z",
            "content_html": "<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><ul>\n<li>多态，是面向对象的程序设计语言最核心的特征。多态，意味着一个对象有着多重特征，可以在特定的情况下，表现不同的状态，从而对应着不同的属性和方法。</li>\n</ul>\n<h2 id=\"多态的作用\"><a href=\"#多态的作用\" class=\"headerlink\" title=\"多态的作用\"></a>多态的作用</h2><ul>\n<li>消除类型之间的耦合关系</li>\n</ul>\n<h2 id=\"主要的特点\"><a href=\"#主要的特点\" class=\"headerlink\" title=\"主要的特点\"></a>主要的特点</h2><ul>\n<li>多态是方法的多态，二不是属性的多态</li>\n<li>多态存在的三个必要条件 <ul>\n<li>要有继承；</li>\n<li>要有重写；</li>\n<li>父类引用指向子类对象。 </li>\n</ul>\n</li>\n<li>用该父类引用调用子类重写的方法</li>\n</ul>\n<h2 id=\"代码演示\"><a href=\"#代码演示\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h2><ul>\n<li><pre><code class=\"lang-java\">public class TextPlay{\n    public static void main(String[] args){\n        Animal a = new Animal();\n        animalCry(a);\n        Dog d = new Dog();\n    }\n\n    static void animalCry(Animal a){\n        a.shout();   //父类引用子类对象\n    }\n}\nclass Animal{\n    public void shout(){\n        System.out.println(&quot;叫&quot;);\n    }\n}\n\nclass Dog extends Animal{  //继承父类\n    public void shout(){\n        System.out.println(&quot;汪汪汪&quot;);//方法重写\n    }\n}\n</code></pre>\n</li>\n</ul>\n<h2 id=\"多态的分类\"><a href=\"#多态的分类\" class=\"headerlink\" title=\"多态的分类\"></a>多态的分类</h2><ul>\n<li><strong>引用多态</strong><ul>\n<li>父类的引用可以指向本类的对象</li>\n<li>父类的引用可以指向子类的对象</li>\n</ul>\n</li>\n<li><strong>方法多态</strong><ul>\n<li>创建本类对象时，调用的方法为本类方法</li>\n<li>创建子类对象时，调用方法为子类重写的方法或者继承的方法  </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"对象的转换（ClassCastException）\"><a href=\"#对象的转换（ClassCastException）\" class=\"headerlink\" title=\"对象的转换（ClassCastException）\"></a>对象的转换（ClassCastException）</h2><ul>\n<li>代码演示<pre><code class=\"lang-java\"> Animal d = new Dog();//自动向上转型\n Dog d2 = (Dog)d;//强制向下转型\n //在Dog类中加上看门的方法，新建一个cat类，则\n animalCry(new Cat());\n Dog d2 = (Dog)d;\n Animal c = new Cat();\n Dog d3 = (Dog) c; //Cat强转Dog，编译未报错，但实际上不能转换\n d3.door();\n</code></pre>\n</li>\n<li>总而言之，子类转向父类没有风险，而父类转向子类会存在风险</li>\n<li>解决方法：我们可以使用<code>instance of</code>运算符，来解决引用对象的类型，避免类型转换的安全性问题<ul>\n<li>例如：<br>```java<br>Dog dog = new Dog();<br>Animal animal = new Dog ;//向上类型转换<br>if(Animal instance of Dog){<br>  Dog dog2 = (Dog)Animal;<br>}else{<br>  System.out.println(“无法进行转换”);<br>}</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"抽象类-abstract\"><a href=\"#抽象类-abstract\" class=\"headerlink\" title=\"抽象类(abstract)\"></a>抽象类(abstract)</h2><h3 id=\"基本了解\"><a href=\"#基本了解\" class=\"headerlink\" title=\"基本了解\"></a>基本了解</h3><ul>\n<li><strong>抽象类</strong>，即只有方法声明，无方法体的一种类，它的出现避免了子类设计的随意性，并严格限制子类设计，为子类提供模板</li>\n</ul>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><ul>\n<li><p>在定义的类前使用<code>abstract</code>关键字修饰的即为抽象类</p>\n<pre><code class=\"lang-java\"> public abstract 类名(){\n\n }\n</code></pre>\n</li>\n</ul>\n<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><ul>\n<li>限制规定子类必须实现某些方法，但不关注实现细节</li>\n</ul>\n<h3 id=\"使用规则\"><a href=\"#使用规则\" class=\"headerlink\" title=\"使用规则\"></a>使用规则</h3><ul>\n<li><code>abstract</code>定义抽象类</li>\n<li><code>abstract</code>定义抽象方法时，只是声明，而不需要实现</li>\n<li>包含抽象方法的类是抽象类</li>\n<li>抽象类可以包含普通方法，也可以没有抽象方法</li>\n<li>抽象类不能直接创建，可以定义引用变量                    </li>\n</ul>\n<h3 id=\"注意的点\"><a href=\"#注意的点\" class=\"headerlink\" title=\"注意的点\"></a>注意的点</h3><ol>\n<li>有抽象方法的类能定义抽象类</li>\n<li>抽象类不能实例化，并且不能用<code>new</code>来实例化抽象类</li>\n<li>抽象类可汗属性、方法、构造方法，但构造方法不能用来<code>new</code>实例，只能用来被子类调用</li>\n<li><strong>抽象类只能用来被继承</strong></li>\n<li><strong>抽象方法必须被子类实现</strong></li>\n</ol>\n<h2 id=\"接口-Interface\"><a href=\"#接口-Interface\" class=\"headerlink\" title=\"接口(Interface)\"></a>接口(Interface)</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li>类是一种具体实现体，而接口定义了某一批类所需要遵守的规范，接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它值规定这些类里必须提供某些方法</li>\n<li>接口的出现，实现了程序设计中设计与实现的分离，可以说是抽象类的延伸</li>\n</ul>\n<h3 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><ul>\n<li><p>修饰符 <code>interface</code> 接口名 <code>extends</code> 父接口1，父接口2{</p>\n<p>}</p>\n<ul>\n<li>修饰符一般建议使用<code>public</code>，不能使用<code>private</code>和<code>protected</code>修饰接口</li>\n</ul>\n</li>\n<li>实际代码演示：<pre><code class=\"lang-java\">  //方法必须公有化\n  public interface flyable{\n      void fly();//这里只能含有常量，抽象方法\n  }\n  class plane implements flyable{\n      //可以实现一个或多个接口\n      public void fly(){\n          System.out.println(&quot;飞机飞起来了&quot;);\n      }\n  }\n</code></pre>\n<h3 id=\"注意的点-1\"><a href=\"#注意的点-1\" class=\"headerlink\" title=\"注意的点\"></a>注意的点</h3></li>\n<li>接口在使用过程中，还经常与匿名内部类配合使用</li>\n<li>匿名内部类就是没有名字的内部类</li>\n<li>多用于关注实现而不关注实现类名称</li>\n<li>接口支持多继承</li>\n<li>接口的字段默认都是<code>static</code>和<code>final</code>                                </li>\n</ul>\n<h2 id=\"回调的实现（callback）\"><a href=\"#回调的实现（callback）\" class=\"headerlink\" title=\"回调的实现（callback）\"></a>回调的实现（callback）</h2><ul>\n<li>多态的扩展</li>\n<li>可以指出某个特定事件发生时应该采取得到动作</li>\n</ul>\n<h2 id=\"内部类（Inner）\"><a href=\"#内部类（Inner）\" class=\"headerlink\" title=\"内部类（Inner）\"></a>内部类（Inner）</h2><ul>\n<li>特点：<ul>\n<li>只能让外部类直接访问，不可在同包中的其他类直接访问</li>\n<li>可访问外部类私有属性，但外部类不能访问内部类的内部属性</li>\n</ul>\n</li>\n<li>使用场景：<ul>\n<li>只为所在外部类通过服务的情况下优先使用</li>\n</ul>\n</li>\n<li>分类<ul>\n<li>成员内部类<ul>\n<li>静态</li>\n<li>非静态</li>\n</ul>\n</li>\n<li>匿名内部类（只用一次的类，也称局部内部类 ）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"异常机制\"><a href=\"#异常机制\" class=\"headerlink\" title=\"异常机制\"></a>异常机制</h2><h3 id=\"何为异常-Excpetion\"><a href=\"#何为异常-Excpetion\" class=\"headerlink\" title=\"何为异常(Excpetion)\"></a>何为异常(Excpetion)</h3><ul>\n<li>异常就是程序中的一些错误，有些异常是可以避免错误的，例如一些IDE可以提示你报错的代码语法错误。<h3 id=\"异常分类\"><a href=\"#异常分类\" class=\"headerlink\" title=\"异常分类\"></a>异常分类</h3></li>\n<li><strong>检查性异常</strong> ： 常见的有用户错误或问题引起的异常</li>\n<li><strong>运行时异常</strong> ： 运行时异常是可以避免的异常，但在编译时常被忽略</li>\n<li><strong>错误</strong> ： 错误不是异常，而是脱离程序员控制的问题，错误在代码中常被忽略<h3 id=\"关于异常\"><a href=\"#关于异常\" class=\"headerlink\" title=\"关于异常\"></a>关于异常</h3></li>\n<li>在Exception分支中有一个重要的子类 <code>RuntimeException</code>(运行时异常)<ul>\n<li><code>ArrayIndexOutOfBoundsException</code> 数组下标越界</li>\n<li><code>NullPointerException</code> 空指针异常</li>\n<li><code>ArithmeicException</code> 算术异常</li>\n<li><code>MissingResourceException</code> 丢失资源</li>\n<li><code>ClassNotFoundException</code>找不到类异常</li>\n</ul>\n</li>\n<li>这些异常都是不检查异常，程序中可选择捕获异常，也可以不处理<h3 id=\"Error与Exception的区别\"><a href=\"#Error与Exception的区别\" class=\"headerlink\" title=\"Error与Exception的区别\"></a>Error与Exception的区别</h3></li>\n<li><code>Error</code>通常是灾难性的致命错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机(JVM)一般会选择终止线程</li>\n<li><code>Exception</code>通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常</li>\n</ul>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "https://peter-pan001.github.io/my-blog/Java/Java%E6%95%B0%E7%BB%84/",
            "url": "https://peter-pan001.github.io/my-blog/Java/Java%E6%95%B0%E7%BB%84/",
            "title": "Java数组",
            "date_published": "2020-10-22T14:53:14.000Z",
            "content_html": "<h2 id=\"数组的基本使用\"><a href=\"#数组的基本使用\" class=\"headerlink\" title=\"数组的基本使用\"></a>数组的基本使用</h2><ul>\n<li>什么是数组？形如<code>int[]score ={79,9,2,45};</code>称作数组</li>\n</ul>\n<h3 id=\"1-1-声明数组\"><a href=\"#1-1-声明数组\" class=\"headerlink\" title=\"1.1 声明数组\"></a>1.1 声明数组</h3><ul>\n<li>语法：<ul>\n<li>数据类型 &nbsp;<code>[]</code>&nbsp;数组名 </li>\n<li>或者：数据类型 &nbsp;数组名[]</li>\n</ul>\n</li>\n<li>例如：<pre><code class=\"lang-java\">int[] scores;//最好采用这种写法\ndouble height[]; //不推荐这种写法\n</code></pre>\n</li>\n<li><strong>注意！</strong><ul>\n<li><strong>在声明数组的同时不能指定数组长度,以下为错误写法</strong><pre><code class=\"lang-java\">int[] arr = new int[4]{95,16,77,25};\n</code></pre>\n<h3 id=\"1-2-分配空间\"><a href=\"#1-2-分配空间\" class=\"headerlink\" title=\"1.2 分配空间\"></a>1.2 分配空间</h3></li>\n</ul>\n</li>\n<li>语法：<ul>\n<li>数组名 &nbsp; <code>=</code> &nbsp;数据类型<code>[</code>数组长度<code>]</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-3-赋值\"><a href=\"#1-3-赋值\" class=\"headerlink\" title=\"1.3 赋值\"></a>1.3 赋值</h3><ul>\n<li>数组从0开始计算（一位数组按顺序排列数字）<ul>\n<li>语法：<pre><code class=\"lang-java\">score[0] = 92;//score数组的一号元素的数值为92\nscore[1] = 98;\n</code></pre>\n<h2 id=\"使用循环操作打印Java数组\"><a href=\"#使用循环操作打印Java数组\" class=\"headerlink\" title=\"使用循环操作打印Java数组\"></a>使用循环操作打印Java数组</h2></li>\n</ul>\n</li>\n<li>代码演示：<pre><code class=\"lang-java\">int[] scores ={88,82,99,86,95};\nfor(int i =0;i&lt;score.length;i++){\n    System.out.println(scores[i]);\n}\n</code></pre>\n<ul>\n<li>数组名<code>.length</code>为获取数组的长度</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"使用Arrays类按顺序打印Java数组\"><a href=\"#使用Arrays类按顺序打印Java数组\" class=\"headerlink\" title=\"使用Arrays类按顺序打印Java数组\"></a>使用Arrays类按顺序打印Java数组</h2><ul>\n<li>首先导入<code>Arrays</code>类<pre><code class=\"lang-java\">import java.utol.Arrays;\n</code></pre>\n</li>\n<li>然后排序<pre><code class=\"lang-java\">Arrays.sort(数组名);\n</code></pre>\n</li>\n<li>整体演示<pre><code class=\"lang-java\">//定义一个整型数组\nint[] score ={75,88,91,64,73};\n//使用Arrays类的sort()方法对数组进行排序\nArrays.sort(score);\n</code></pre>\n<h2 id=\"将数组转换为字符串\"><a href=\"#将数组转换为字符串\" class=\"headerlink\" title=\"将数组转换为字符串\"></a>将数组转换为字符串</h2></li>\n<li>语法：<pre><code class=\"lang-java\">Array.toString(数组名);\n</code></pre>\n</li>\n<li>例如：<pre><code class=\"lang-java\">System.out.println(Array.toString(scores));\n</code></pre>\n</li>\n</ul>\n<h2 id=\"使用for-each遍历数组\"><a href=\"#使用for-each遍历数组\" class=\"headerlink\" title=\"使用for-each遍历数组\"></a>使用for-each遍历数组</h2><ul>\n<li>语法：<pre><code class=\"lang-java\">for(元素类型 元素变量  : 遍历对象){\n    执行的代码;\n}\n</code></pre>\n</li>\n<li>例如<pre><code class=\"lang-java\">//对一维数组而言\nint arr[] = {2, 3, 1};\nfor (int x : arr) { \nSystem.out.println(x); //逐个输出数组元素的值 \n//对List数组来说\n//创建List并添加元素 \nList&lt;String&gt; list = new ArrayList&lt;String&gt;(); \nlist.add(&quot;1&quot;); \nlist.add(&quot;3&quot;); \nlist.add(&quot;4&quot;); \n//利用froeach语句输出集合元素 \nSystem.out.println(&quot;----2----froeach语句输出集合元素&quot;); \nfor (String x : list) { \nSystem.out.println(x); \n}\n</code></pre>\n</li>\n</ul>\n<h2 id=\"Java中使用二维数组\"><a href=\"#Java中使用二维数组\" class=\"headerlink\" title=\"Java中使用二维数组\"></a>Java中使用二维数组</h2><ol>\n<li>声明数组并分配空间<ul>\n<li>数据类型 &nbsp;<code>[][]</code> 数组名 <code>=</code> <code>new</code> 数据类型 <code>[</code>行的个数<code>]``[</code>列的个数<code>]</code>;</li>\n<li>例如：<pre><code class=\"lang-java\">int [][] nums = new int[5][6];\n</code></pre>\n</li>\n</ul>\n</li>\n<li>赋值<ul>\n<li>数组名<code>[</code>行索引<code>]``[</code>列索引<code>]</code> = 值;</li>\n</ul>\n</li>\n<li>处理数组</li>\n</ol>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "https://peter-pan001.github.io/my-blog/Java/Java%E6%96%B9%E6%B3%95/",
            "url": "https://peter-pan001.github.io/my-blog/Java/Java%E6%96%B9%E6%B3%95/",
            "title": "Java方法",
            "date_published": "2020-10-22T14:53:14.000Z",
            "content_html": "<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ul>\n<li>语法：<br>访问修饰符 返回值类型 方法名(参数列表){<pre><code>方法体\n</code></pre>}</li>\n<li><strong>访问修饰符：</strong>方法运行被访问的权限范围，通常可以设置为<code>public</code>,<code>protected</code>,<code>private</code>,甚至可以省略</li>\n<li><strong>返回值类型：</strong>方法返回值的类型，如果方法不返回任何值，则返回值类型指定为<code>void</code>;如果方法具有返回值，则需要指定返回值类型，并且在方法体中使用<code>return</code>语句返回值</li>\n<li><strong>方法名：</strong>定义方法的名字，必须使用合法的标识符</li>\n<li><strong>参数列表：</strong>可以有多个，多个参数之间用逗号隔开，每个参数由参数类型和参数名组成，此时方法分成四类<ul>\n<li><strong>无参无返回值的方法</strong></li>\n<li><strong>无参有返回值的方法</strong></li>\n<li><strong>有参无返回值的方法</strong></li>\n<li><strong>有参有返回值的方法</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-1-无参无返回值方法的使用\"><a href=\"#1-1-无参无返回值方法的使用\" class=\"headerlink\" title=\"1.1 无参无返回值方法的使用\"></a>1.1 无参无返回值方法的使用</h3><ul>\n<li>第一步：定义方法（即概述中的语法）</li>\n<li>第二步：调用方法<ul>\n<li>先创建类的对象，再通过对象名<code>.</code>方法名<code>(``)</code>;实现</li>\n<li>例如：<pre><code class=\"lang-java\">public class Person{\n    Person teacher = new Person();\n    public void teach{\n        System.out.println(&quot;teaching.....&quot;);\n    }\n    teacher.teach();\n}\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-无参有返回值方法的使用\"><a href=\"#1-2-无参有返回值方法的使用\" class=\"headerlink\" title=\"1.2 无参有返回值方法的使用\"></a>1.2 无参有返回值方法的使用</h3><ul>\n<li><p>例如：</p>\n<p><img data-src=\"https://i.loli.net/2020/10/22/9lLHstn56icf8jG.png\" alt=\"methodreturn.png\"></p>\n</li>\n<li><p>重点：</p>\n<ul>\n<li><ol>\n<li>如果方法的返回类型为<code>void</code>，则方法中不能使用<code>return</code>返回</li>\n</ol>\n</li>\n<li><ol>\n<li>方法的返回值最多只能有一个，不能返回多个值</li>\n</ol>\n</li>\n<li><ol>\n<li>方法返回值的类型必须兼容</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-3-有参无返回值方法的使用\"><a href=\"#1-3-有参无返回值方法的使用\" class=\"headerlink\" title=\"1.3 有参无返回值方法的使用\"></a>1.3 有参无返回值方法的使用</h3><ul>\n<li><p>语法：</p>\n<ul>\n<li>对象名<code>.</code>方法名<code>(</code>实参1,实参2,….<code>)</code></li>\n</ul>\n</li>\n<li><p><strong>注意</strong></p>\n<ul>\n<li>调用带参方法时，必须保证实参的数量，类型，数据顺序与形参一一对应</li>\n<li>调用方法时，实参不需要知道数据类型</li>\n<li>方法的参数可以是基本类型，也可以是引用类型（即String，数组）</li>\n<li>当方法参数有多个时，使用逗号分隔</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"方法的重载\"><a href=\"#方法的重载\" class=\"headerlink\" title=\"方法的重载\"></a>方法的重载</h2><ul>\n<li><strong>概念理解：</strong>如果同一个类包含了两个或两个以上方法名相同，方法参数的个数、顺序或类型不同的方法<ul>\n<li>判断依据<ol>\n<li>必须是在同一个类中</li>\n<li>方法名相同</li>\n<li>方法参数的个数、顺序或类型不同</li>\n<li>与方法的修饰符或返回值没有关系 </li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "https://peter-pan001.github.io/my-blog/Java/Java%E7%9A%84Stream%E6%B5%81/",
            "url": "https://peter-pan001.github.io/my-blog/Java/Java%E7%9A%84Stream%E6%B5%81/",
            "title": "Java的Stream流",
            "date_published": "2020-10-22T14:53:14.000Z",
            "content_html": "<h2 id=\"第一章-简单体验一下Stream流\"><a href=\"#第一章-简单体验一下Stream流\" class=\"headerlink\" title=\"第一章 简单体验一下Stream流\"></a>第一章 简单体验一下Stream流</h2><ul>\n<li>我们使用Stream流的方式，可以用来遍历集合，对集合中的数据进行过滤等，Stream流是在jdk1.8之后出现 </li>\n<li>代码示例<pre><code class=\"lang-java\">public class DemoTextStream{\n  public static void main(String[] args){\n      // 创建一个list集合，用来存储姓名\n      List&lt;String&gt; list = new ArrayList&lt;&gt;();\n      list.add(&quot;李冰冰&quot;);\n      list.add(&quot;彭于晏&quot;);\n      list.add(&quot;李易峰&quot;);\n      list.add(&quot;李沁&quot;);\n      list.add(&quot;王思聪&quot;);\n      // 对List集合的元素进行过滤，只要以张开头的元素，存储到一个新的集合中\n      // 对listA集合进行过滤，只要姓名长度为三的人\n      // 遍历集合\n      list.Stream()\n              .filter(name-&gt;name.startsWith(&quot;李&quot;))\n              .filter(name-&gt;name.length()==3)\n              .foreach(name-&gt;System.out.println(name));\n  }\n}\n</code></pre>\n<h3 id=\"流式思想的概述\"><a href=\"#流式思想的概述\" class=\"headerlink\" title=\"流式思想的概述\"></a>流式思想的概述</h3><blockquote>\n<p>对于流式思想，可以<strong>把它想象成工厂的“流水线”</strong>。通过一系列的加工、过滤得到最后的产品</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h3 id=\"何为Stream\"><a href=\"#何为Stream\" class=\"headerlink\" title=\"何为Stream\"></a>何为Stream</h3><ul>\n<li><strong>Stream流实际上是一个来自数据源的元素队列</strong></li>\n<li><strong>Java中的Stream并不会存储元素，而是按需计算</strong></li>\n<li><strong>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</strong></li>\n</ul>\n<hr>\n<h2 id=\"第二章-获取Stream流的方式\"><a href=\"#第二章-获取Stream流的方式\" class=\"headerlink\" title=\"第二章 获取Stream流的方式\"></a>第二章 获取Stream流的方式</h2><h2 id=\"java-util-stream-Stream-lt-T-gt-是java中新加入的最常用的流接口\"><a href=\"#java-util-stream-Stream-lt-T-gt-是java中新加入的最常用的流接口\" class=\"headerlink\" title=\"- java.util.stream.Stream&lt;T&gt;是java中新加入的最常用的流接口\"></a>- <code>java.util.stream.Stream&lt;T&gt;</code>是java中新加入的<strong>最常用的流接口</strong></h2><ul>\n<li><p><strong>获取流的两种方式</strong></p>\n<ul>\n<li><strong>所有的collection集合都可以通过stream默认方法获取流</strong></li>\n<li><p><strong>Stream接口的静态方法of可以获取数组对应的流</strong><code>static&lt;T&gt; Stream&lt;T&gt; of(T...values)</code>参数是一个<strong>可变参数</strong>，可以通过这个方法传递一个数组</p>\n<ul>\n<li><p>代码演示：</p>\n<pre><code class=\"lang-java\">public class DemoMethodAcq{\n  public static void main(String[] args){\n      //把集合转换为Stream流\n      List&lt;String&gt; list = new Arraylist&lt;String&gt;();\n      Stream&lt;String&gt; str = list.stream();\n\n      Set&lt;String&gt; set = new HashSet&lt;&gt;();\n      Stream&lt;String&gt; stream2 = set.stream();\n\n      Map&lt;String,String&gt; map = new HashMap&lt;&gt;();\n      //获取键，存储到一个Set集合中\n      Set&lt;String&gt; keyset =map.keyset();\n      Stream&lt;String&gt; Stream3 = keyset.stream();\n\n      //获取值，存储到一个Collection集合中\n      Collection&lt;String&gt; values = map.values();\n      Stream&lt;String&gt; stream4 = values.stream();\n\n      //获取键值对\n      Set&lt;Map.Entry&lt;String,String&gt;&gt; entries = map.entries();\n      Stream&lt;Map.Entry&lt;String,String&gt;&gt; stream5 = entries.stream();\n\n      //把数组转换为Stream流\n      Stream&lt;Integer&gt; stream6 = Stream.of(1,2,3,4,5);\n      //可变参数可以传递数组\n      Integer[] arr = {1,2,3,4,5};\n      Stream&lt;Integer&gt; stream7 = Stream.of(arr);\n      String[] arr2 ={&quot;a&quot;,&quot;bb&quot;,&quot;ccc&quot;};\n      Stream&lt;String&gt; stream8 = Stream.of(arr2);\n\n  }\n}\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"第三章-Stream流的常用方法\"><a href=\"#第三章-Stream流的常用方法\" class=\"headerlink\" title=\"第三章 Stream流的常用方法\"></a>第三章 Stream流的常用方法</h2><blockquote>\n<p>流模型的操作被分为两种方法：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<strong>延迟方法</strong>:&nbsp;&nbsp;&nbsp;返回值类型仍然是<code>Stream</code>接口自身类型的方法，因此支持链式调用（除了延时方法其他均为终结方法）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.<strong>终结方法</strong>:&nbsp;&nbsp;&nbsp;返回值类型不在是<code>Stream</code>接口自身类型的方法，因此不在支持类似<code>StringBuilder</code>那样的链式调用（终结方法包括<code>count</code>和<code>forEach</code>方法）</p>\n<h3 id=\"1、forEach方法（逐一处理）\"><a href=\"#1、forEach方法（逐一处理）\" class=\"headerlink\" title=\"1、forEach方法（逐一处理）\"></a>1、forEach方法（逐一处理）</h3><ul>\n<li>首先，此方法<strong>非for循环的for-each循环方法</strong></li>\n<li>其标准格式为：<pre><code class=\"lang-java\">void forEach(Consumer&lt;? suoer T&gt; action);\n</code></pre>\n</li>\n</ul>\n<hr>\n<ul>\n<li><strong>forEach方法是通过接收一个Consumer接口函数，会使每一个流元素交给该函数处理</strong></li>\n<li>可以简记为：<ul>\n<li>forEach是用来遍历流数据的</li>\n<li>它是一个终结方法，遍历之后就不能继续调用Stream流中的其他方法</li>\n</ul>\n</li>\n<li>代码演示：<pre><code class=\"lang-java\">public class Demo_forEach{\n    public static void main(String[] args){\n        //获取一个Stream流\n        Stream&lt;String&gt; stream = Stream.of(&quot;张三&quot;，&quot;李四&quot;，&quot;w王五&quot;，&quot;赵六&quot;);\n        //使用Stream流中的方法forEach对Stream流中的数据进行遍历\n        stream.forEach((String name)-&gt; {\n            System.out.println(name);\n        });\n        /* 简写可以这样：\n         stream.forEach(name-&gt; \n            System.out.println(name)\n        );\n        */\n    }\n}\n</code></pre>\n<h3 id=\"2、filter方法（过滤）\"><a href=\"#2、filter方法（过滤）\" class=\"headerlink\" title=\"2、filter方法（过滤）\"></a>2、filter方法（过滤）</h3></li>\n<li><strong>使用<code>filter</code>方法可以将一个流转换成另一个字节流</strong><pre><code class=\"lang-java\">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);\n</code></pre>\n<ul>\n<li>此接口接收一个<code>Predicate</code>函数式接口参数作为筛选条件,即：<pre><code class=\"lang-java\">boolean test(T t);\n</code></pre>\n<ul>\n<li>该方法是Predicate接口中的一个抽象方法<pre><code class=\"lang-java\">public class Demo_filter{\npublic static void main(String[] args){\n    //创建一个Stream流\n    Stream&lt;String&gt; stream = Stream.of(&quot;李冰冰&quot;,&quot;李易峰&quot;,&quot;彭于晏&quot;,&quot;李沁&quot;,&quot;王思聪&quot;);\n    //对Stream流中的元素进行过滤，筛选出姓“李”的人\n    Stream&lt;String&gt; stream2 = stream.filter((String name)-&gt;{\n        return name.startWith(&quot;李&quot;);\n    });\n    //遍历stream2\n    stream.forEach(name-&gt; System.out.println(name));\n}\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Stream流属于管道流，只能被消费一次</strong></li>\n<li><strong>第一次Stream流调用完毕后，数据会流到下一个Stream上</strong></li>\n<li><strong>此时第一个Stream流消费完毕，就会关闭</strong></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"3、map方法（映射）\"><a href=\"#3、map方法（映射）\" class=\"headerlink\" title=\"3、map方法（映射）\"></a>3、map方法（映射）</h3><ul>\n<li><strong>map方法</strong>是将流中的元素映射到另一个流中，可以使用map方法<pre><code class=\"lang-java\">&lt;R&gt; Stream&lt;R&gt; map{Function&lt;? super T,? extends R&gt; mapper};\n</code></pre>\n<ul>\n<li>该接口需要一个<code>Function</code>的函数式接口参数</li>\n<li>使用的是Function接口的抽象方法：<br><code>R apply(T t);</code></li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li>代码演示：<pre><code class=\"lang-java\">public class Demo_map{\n    public static void main(String[] args){\n        //获取一个String类型的Stream流\n        Stream&lt;String&gt; stream = Stream.of(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;);\n        //使用map方法，把字符串类型的整数，转换（映射）到Integer类型的整数\n        Stream&lt;Integer&gt; stream2 = stream.map((String s)-&gt;{\n            return Integer.parseInt(s);\n        });\n        //遍历stream2\n        stream2.forEach(i-&gt; System.out.println(i));\n    }\n}\n</code></pre>\n<h3 id=\"4、count方法（统计个数）\"><a href=\"#4、count方法（统计个数）\" class=\"headerlink\" title=\"4、count方法（统计个数）\"></a>4、count方法（统计个数）</h3></li>\n<li>Stream流通过<code>count</code>方法来对流中的元素进行统计，即：<pre><code class=\"lang-java\">long count();\n</code></pre>\n</li>\n<li><strong>count方法是一个终结方法，返回值是一个Long类型的整数，不能再继续调用Stream流中的其他方法</strong></li>\n<li><p>代码示例：</p>\n<pre><code class=\"lang-java\">import java.util.stream.Stream;\n\npublic class Demo_count{\n    public static void main(String[] args){\n        Stream&lt;String&gt; stream = Stream.of(&quot;李冰冰&quot;,&quot;李易峰&quot;,&quot;王思聪&quot;);\n        Stream&lt;String&gt; result = stream.filter(s-&gt; s.startWith(&quot;李&quot;));\n        System.out.println(result.count());//输出为2\n\n    }\n}\n</code></pre>\n<h3 id=\"5、limit方法（截取使用前几个）\"><a href=\"#5、limit方法（截取使用前几个）\" class=\"headerlink\" title=\"5、limit方法（截取使用前几个）\"></a>5、limit方法（截取使用前几个）</h3></li>\n<li><pre><code class=\"lang-limit```方法可以对流进行截取，只取用前n个，即：\">```java\nStream&lt;T&gt; limit(long maxSize);\n</code></pre>\n<ul>\n<li>参数是一个Long类型，如果集合当前长度大于参数则进行截取，否则不操作</li>\n<li><strong>limit方法是一个延迟方法，返回的是一个新的流，可以调用Stream流的其他方法</strong></li>\n<li>代码展示：<pre><code class=\"lang-java\">public class Demo_limit{\n  public static void main(String[] args){\n      //获取一个Stream流\n      String[] arr = {&quot;李冰冰&quot;,&quot;李易峰&quot;,&quot;王思聪&quot;};\n      Stream&lt;String&gt; stream = Stream.of(arr);\n      //使用Limit对Stream流中的元素进行截取，只要前2个元素\n      Stream&lt;String&gt; stream2 =stream.limit(2);\n      //遍历stream2\n      stream2.forEach(name-&gt; System.out.println(name));\n  }\n}\n</code></pre>\n<h3 id=\"6、skip方法（跳过前几个）\"><a href=\"#6、skip方法（跳过前几个）\" class=\"headerlink\" title=\"6、skip方法（跳过前几个）\"></a>6、skip方法（跳过前几个）</h3></li>\n</ul>\n</li>\n<li>如果需要跳过前几个元素，可以使用<code>skip</code>方法进行截取流，即：<pre><code class=\"lang-java\">Stream&lt;T&gt; skip(long n);\n</code></pre>\n<ul>\n<li>若要跳过的元素个数n大于流中元素的个数，则会截取流，得到一个长度为0的空流（新流）</li>\n<li>代码展示：<pre><code class=\"lang-java\"> public class Demo_limit{\n        public static void main(String[] args){\n        //获取一个Stream流\n        String[] arr = {&quot;李冰冰&quot;,&quot;李易峰&quot;,&quot;王思聪&quot;};\n        Stream&lt;String&gt; stream = Stream.of(arr);\n        //使用skip跳过前2个元素\n        Stream&lt;String&gt; stream2 =stream.skip(2);\n        //遍历stream2\n        stream2.forEach(name-&gt; System.out.println(name));\n    }\n}\n</code></pre>\n<h3 id=\"7、concat方法（组合）\"><a href=\"#7、concat方法（组合）\" class=\"headerlink\" title=\"7、concat方法（组合）\"></a>7、concat方法（组合）</h3></li>\n</ul>\n</li>\n<li><p>如果有两个流，需要合并为一个流，则需要使用<code>concat</code>静态方法，即：</p>\n<pre><code class=\"lang-java\">static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b);\n</code></pre>\n<blockquote>\n<p>备注：这是一个静态方法，与<code>java.lang.String</code>当中的<code>concat</code>方法不同</p>\n<ul>\n<li>代码展示：<br>```java<br>import java.util.stream.Stream;</li>\n</ul>\n</blockquote>\n<p>public class Demo_concat{</p>\n<pre><code>public static void main(String[] args){\n    Stream&lt;String&gt; streamA = Stream.of(&quot;李冰冰&quot;);\n    Stream&lt;String&gt; streamB = Stream.of(&quot;李易峰&quot;);\n    Stream&lt;String&gt; result = Stream.concat(streamA,streamB);\n}\n</code></pre><p>}<br>```</p>\n</li>\n</ul>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "https://peter-pan001.github.io/my-blog/Java/Java%E7%BB%A7%E6%89%BF/",
            "url": "https://peter-pan001.github.io/my-blog/Java/Java%E7%BB%A7%E6%89%BF/",
            "title": "Java继承",
            "date_published": "2020-10-22T14:53:14.000Z",
            "content_html": "<h2 id=\"关于继承\"><a href=\"#关于继承\" class=\"headerlink\" title=\"关于继承\"></a>关于继承</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li>继承是类与类的一种关系，是一种“is a”的关系</li>\n<li>继承可以使得子类具有父类别的各种属性和方法，而<strong>不需要再次编写相同的代码</strong>。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。</li>\n</ul>\n<h3 id=\"继承的特性\"><a href=\"#继承的特性\" class=\"headerlink\" title=\"继承的特性\"></a>继承的特性</h3><ul>\n<li>Java只有单继承，即只有一个父类</li>\n<li>没有调用<code>extend</code>，则父类为<code>java.lang</code></li>\n<li>使用<code>instance of</code>判断对象类型</li>\n</ul>\n<h3 id=\"超类、子类\"><a href=\"#超类、子类\" class=\"headerlink\" title=\"超类、子类\"></a>超类、子类</h3><ul>\n<li>对于java中继承的某些知识，在这里需要给读者插补一点类的基本知识，让文章更具有可读性</li>\n</ul>\n<h4 id=\"超类\"><a href=\"#超类\" class=\"headerlink\" title=\"超类\"></a>超类</h4><ul>\n<li>超类，也称父类，Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有<code>Object</code>类特殊，它没有父类，所有它是所有类的父类。</li>\n</ul>\n<h4 id=\"子类\"><a href=\"#子类\" class=\"headerlink\" title=\"子类\"></a>子类</h4><ul>\n<li>子类就是继承父类的所有方法，在此基础上在实现子类自己的一些方法</li>\n</ul>\n<h3 id=\"继承的优点\"><a href=\"#继承的优点\" class=\"headerlink\" title=\"继承的优点\"></a>继承的优点</h3><ol>\n<li>子类拥有父类的属性和方法</li>\n<li>实现代码复用</li>\n</ol>\n<h3 id=\"使用语法\"><a href=\"#使用语法\" class=\"headerlink\" title=\"使用语法\"></a>使用语法</h3><pre><code class=\"lang-java\">Class Student extends Person{\n\n}//student就是子类，Person就是父类\n</code></pre>\n<h3 id=\"继承的初始化顺序\"><a href=\"#继承的初始化顺序\" class=\"headerlink\" title=\"继承的初始化顺序\"></a>继承的初始化顺序</h3><ul>\n<li>初始化父类在初始化子类</li>\n<li>先执行初始化对象中的属性，再执行构造方法中的初始化</li>\n<li><img data-src=\"https://i.loli.net/2020/10/22/DFxfgikLnOCmu2E.png\" alt=\"initialstep.png\"></li>\n</ul>\n<h2 id=\"方法的重写-override\"><a href=\"#方法的重写-override\" class=\"headerlink\" title=\"方法的重写(override)\"></a>方法的重写(override)</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li>如果子类对继承父类的方法不满意，是可以重写父类继承的方法的，当调用方法时会优先调用子类的方法</li>\n<li>使用规则：<ul>\n<li><code>@override</code>的注释下的方法即为重写的方法，其本质是覆盖父类的方法</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"语法规则\"><a href=\"#语法规则\" class=\"headerlink\" title=\"语法规则\"></a>语法规则</h3><ul>\n<li><strong>返回值类型、方法名、参数类型与个数这三者必须与父类继承的方法相同，这样才叫做方法的重写</strong></li>\n<li><strong>子类访问权限大于父类访问权限</strong></li>\n</ul>\n<h2 id=\"final关键字\"><a href=\"#final关键字\" class=\"headerlink\" title=\"final关键字\"></a>final关键字</h2><ul>\n<li><code>final</code>,即“最终的”</li>\n<li><code>final</code>可以修饰类、方法、属性和变量<ul>\n<li><code>final</code>修饰类，则该类<strong>不允许被继承</strong></li>\n<li><code>final</code>修饰方法，则该方法<strong>不允许被覆盖（重写）</strong></li>\n<li><code>final</code>修饰属性，则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在构造方法中赋值</li>\n<li><code>final</code>修饰变量，则该变量的值<strong>只能赋一次值</strong>，即为常量</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Super关键字\"><a href=\"#Super关键字\" class=\"headerlink\" title=\"Super关键字\"></a>Super关键字</h2><h3 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li><code>super</code>关键字是指示编译器调用超类方法的特殊关键字</li>\n<li>直接父类对象的引用，通过<code>super</code>来访问父类中被子类覆盖的方法或属性</li>\n<li>在对象内部使用，可以代表父类对象</li>\n</ul>\n<h3 id=\"使用语法-1\"><a href=\"#使用语法-1\" class=\"headerlink\" title=\"使用语法\"></a>使用语法</h3><ul>\n<li>对父类属性的访问<pre><code class=\"lang-java\">super.age;//age是父类的一个属性\n</code></pre>\n</li>\n<li>对父类方法的访问<pre><code class=\"lang-java\">super.eat();\n</code></pre>\n</li>\n<li>调用父类<code>toString</code>方法<pre><code class=\"lang-java\">super.toString();//默认父类为object类\n//输出格式为：全路径@全限定名Hashcode\n</code></pre>\n</li>\n<li><strong>特殊使用法！！！</strong><pre><code class=\"lang-java\">super(变量1，变量2)\n</code></pre>\n<ul>\n<li>这样使用会使父类的私有域进行初始化，也称调用超类的构造器  </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"super应用\"><a href=\"#super应用\" class=\"headerlink\" title=\"super应用\"></a>super应用</h3><ul>\n<li>子类在构造过程中必须调用其父类的构造方法</li>\n<li>如果子类的构造方法中没有显示调用父类的构造方法，则系统默认调用父类无参的构造方法</li>\n<li>如果显示的调用构造方法，必须在子类的构造方法的<strong>第一行</strong></li>\n<li>如果子类构造方法中既没有显式调用父类的构造方法，二父类又没有无参的构造方法，则编译出错</li>\n</ul>\n<h2 id=\"Object类\"><a href=\"#Object类\" class=\"headerlink\" title=\"Object类\"></a>Object类</h2><h3 id=\"概念-3\"><a href=\"#概念-3\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li><code>Object</code>类是所有类的父类，如果一个类没有使用<code>extends</code>关键字来明确标识继承另一个类，那么这个类默认继承<code>object</code>类</li>\n</ul>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><ol>\n<li><code>toString()</code>方法<ul>\n<li>在<code>Object</code>类中定义<code>toString()</code>方法的时候放的对象时哈希码（即对象地址字符串）</li>\n</ul>\n</li>\n<li><code>equals()</code>方法<ul>\n<li>比较的是对象的引用是否执行同一块内存地址</li>\n<li>一般情况下比较两个对象时比较它的值是否一致，所有要进行重写<code>@Override</code> </li>\n</ul>\n</li>\n</ol>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "https://peter-pan001.github.io/my-blog/Java/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/",
            "url": "https://peter-pan001.github.io/my-blog/Java/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/",
            "title": "Java网络编程",
            "date_published": "2020-10-22T14:53:14.000Z",
            "content_html": "<h2 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h2><hr>\n<ul>\n<li>计算机之间通过传输介质、通信设施和网络通信协议互联，实现资源共享和数据传输。而我们的网络编程就是<strong>使用程序使互联网的两个（或多个）计算机之间进行数据传输。</strong>当然java语言，为了实现两个计算机之间的数据传输，提供了一系列的接口，使得开发人员可以方便的实现。</li>\n</ul>\n<h2 id=\"2、OSI与TCP-IP模型\"><a href=\"#2、OSI与TCP-IP模型\" class=\"headerlink\" title=\"2、OSI与TCP/IP模型\"></a>2、OSI与TCP/IP模型</h2><hr>\n<h3 id=\"模型对比\"><a href=\"#模型对比\" class=\"headerlink\" title=\"模型对比\"></a>模型对比</h3><p><img data-src=\"http://ww1.sinaimg.cn/large/007uxMgDgy1gizstyuicoj30m80h0gne.jpg\" alt=\"image-20200623105550900.png\"></p>\n<ul>\n<li>TCP/IP支持跨层封装 ；但OSI不支持</li>\n<li>TCP/IP仅仅支持IP网络协议 ；OSI支持多种网络层协议</li>\n<li>TCP是面向连接的可靠的传输协议</li>\n<li>UDP是非面向连接的不可靠的传输协议</li>\n</ul>\n<h3 id=\"TCP-IP模型中的协议剖析\"><a href=\"#TCP-IP模型中的协议剖析\" class=\"headerlink\" title=\"TCP/IP模型中的协议剖析\"></a>TCP/IP模型中的协议剖析</h3><p><img data-src=\"http://ww1.sinaimg.cn/large/007uxMgDgy1gizsusacczj30ta0gbtab.jpg\" alt=\"image-20200623110038567.png\"></p>\n<ul>\n<li><p><strong>该模型中几个主要的协议术语及其作用</strong></p>\n<ul>\n<li><p><strong>TCP（传输控制协议）</strong>：通过使用一个校验码检验数据是否发生错误，在接收和转发中都使用计算校验和，并同时对数据进行加密</p>\n</li>\n<li><p><strong>UDP（用户数据报协议）</strong>：UDP使用底层的互联网协议来传送报文，同IP一样提供不可靠的无连接数据包传输服务。它不提供报文到达确认、排序、及流量控制等功能</p>\n</li>\n<li><p><strong>FTP（文件传输协议）</strong>：让用户连接上一个远程计算机（这些计算机上运行着FTP服务器程序）察看远程计算机有哪些文件，然后把文件从远程计算机上拷到本地计算机，或把本地计算机的文件送到远程计算机去。</p>\n</li>\n<li><p><strong>SMTP（邮件消息传输协议）</strong>：SMTP是一种提供可靠且有效电子邮件传输的协议。它是建立在FTP文件传输服务上的一种邮件服务，主要用于传输系统之间的邮件信息并提供来信有关的通知。</p>\n<blockquote>\n<p> SMTP重要的特性之一是它能跨越网络传输邮件，也即“SMTP邮件中继”。使用SMTP，可实现相同网络上处理机之间的邮件传输，也可以通过中继器或网关实现某处理机与其它网络之间的邮件传输。具有域名服务系统(DNS)功能的邮件交换服务器还可以用来识别出传输邮件的下一跳IP地址。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3、IP\"><a href=\"#3、IP\" class=\"headerlink\" title=\"3、IP\"></a>3、IP</h2><hr>\n<ul>\n<li><strong>IP（网际协议）</strong> ：提高网络可扩展性，为主机提供一种无连接的数据传输服务</li>\n<li>唯一定位一台网络上的计算机</li>\n<li><code>127.0.0.1</code>为本机地址<code>localhost</code></li>\n</ul>\n<h2 id=\"4、端口（port）\"><a href=\"#4、端口（port）\" class=\"headerlink\" title=\"4、端口（port）\"></a>4、端口（port）</h2><hr>\n<ul>\n<li><p>端口表示计算机的一个程序的进程</p>\n<ul>\n<li><p>不同的进程有不同的端口号，并且端口号不能重复（单个协议下）</p>\n</li>\n<li><p>端口号范围限制为 0 ~ 65535</p>\n</li>\n<li><p>端口分类</p>\n<ul>\n<li><p>公有端口 0 ~ 1023</p>\n<ul>\n<li>HTTP ：80</li>\n<li>HTTPS ：443</li>\n<li>FTP ： 21</li>\n<li>Telnet ：23</li>\n</ul>\n</li>\n<li><p>程序注册端口： 1024 ~ 49151 分配用户或程序</p>\n<ul>\n<li>Tomcat ：8080</li>\n<li>MySQL ：3306</li>\n<li>Oracle ：1521</li>\n</ul>\n</li>\n<li><p>动态私有 49152 ~ 65535</p>\n<pre><code class=\"lang-bash\"> netstat -ano #查看所有端口\n netstat -ano|findstr &quot;8080&quot; # 查看指定端口\n tasklist|findstr &quot;8696&quot; # 查看指定端口的进程\n ctrl + shift +ESC # 调用任务管理器\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"5、TCP实现聊天\"><a href=\"#5、TCP实现聊天\" class=\"headerlink\" title=\"5、TCP实现聊天\"></a>5、TCP实现聊天</h2><hr>\n<ul>\n<li><p><strong>客户端（Client）</strong></p>\n<ol>\n<li><p>获取服务端的地址与端口号</p>\n</li>\n<li><p>连接服务器端口，建立socket连接</p>\n</li>\n<li><p>发送信息（IO流）</p>\n</li>\n<li><p>关闭资源</p>\n<pre><code class=\"lang-java\">Socket socket = null;\nOutputStream os = null;\n        try {\n\n            //首先要知道服务端的地址和端口号\n            InetAddress serverIp = InetAddress.getByName(&quot;127.0.0.1&quot;);\n            int port = 9999;\n\n            //建立socket连接\n            socket = new Socket(serverIp,9999);\n\n            //发送信息\n            os = socket.getOutputStream();\n            os.write(&quot;我们已经成为好友，可以开始聊天&quot;.getBytes());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n            if (os != null){\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (socket != null){\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n        }\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p><strong>服务端（Server）</strong></p>\n<ol>\n<li><p>建立socket服务器端口</p>\n</li>\n<li><p>调用端口的accept方法,等待用户端连接</p>\n</li>\n<li><p>读取用户信息（IO流）的inputStream</p>\n</li>\n<li><p>建立管道流，把数据从字节流转换为字符流</p>\n</li>\n<li><p>关闭资源</p>\n<pre><code class=\"lang-java\">    ServerSocket serverSocket = null;\n     Socket socket = null;\n      InputStream is = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            //给一个服务端的地址\n             serverSocket = new ServerSocket(9999);\n            //等待客户端接入\n             socket = serverSocket.accept();\n            //读取客户端信息\n             is = socket.getInputStream();\n\n            //管道流\n             baos = new ByteArrayOutputStream();\n            byte[] buffer = new byte[1024];\n            int len;\n            while ((len=is.read(buffer))!= -1){\n                baos.write(buffer,0,len);\n            }\n            System.out.println(baos.toString());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            //关闭资源\n            if(baos !=null){\n                try {\n                    baos.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (is !=null){\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (socket != null){\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (serverSocket != null){\n                try {\n                    serverSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"6、TCP实现文件上传\"><a href=\"#6、TCP实现文件上传\" class=\"headerlink\" title=\"6、TCP实现文件上传\"></a>6、TCP实现文件上传</h2><hr>\n<ul>\n<li><p><strong>服务端（Server）</strong></p>\n<pre><code class=\"lang-java\"> public static void main(String[] args) throws Exception {\n         //创建服务\n         ServerSocket serverSocket = new ServerSocket(9000);\n         //监听客户端连接\n         Socket socket = serverSocket.accept();\n         //获取输入流\n         InputStream is = socket.getInputStream();\n         //此处写文件路径最好使用绝对路径，否则会报错\n         File file = new File(&quot;G://IDEA_Project/FIST/src/receive.jpg&quot;);\n         //文件输出\n         FileOutputStream fos = new FileOutputStream(file);\n         byte[] buffer = new byte[1024];\n         int len;\n         while ((len = is.read(buffer))!=-1){\n             fos.write(buffer,0,len);\n         }\n\n         //通知客户端接收完毕\n         OutputStream os = socket.getOutputStream();\n         os.write(&quot;服务端接收完毕，你可以断开连接&quot;.getBytes());\n\n         //关闭资源 (后创建先关闭原则)\n         fos.close();\n         is.close();\n         socket.close();\n         serverSocket.close();\n     }\n</code></pre>\n</li>\n</ul>\n<ul>\n<li><p><strong>客户端（client）</strong></p>\n<pre><code class=\"lang-java\"> public static void main(String[] args) throws Exception {\n         //创建一个socket连接\n         Socket socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;), 9000);\n         //建立一个输出流\n         OutputStream os = socket.getOutputStream();\n         //此处写文件路径最好使用绝对路径，否则会报错\n         File file = new File(&quot;G://IDEA_Project/FIST/src/lld.jpg&quot;);\n         //读取文件\n         FileInputStream fis = new FileInputStream(file);\n         //写入文件\n         byte[] buffer = new byte[1024];\n         int len;\n         while ((len= fis.read(buffer)) !=-1){\n             os.write(buffer,0,len);\n         }\n         //通知服务器，我已经结束啦\n         socket.shutdownOutput();\n\n         //确认服务端接收完毕，才断开连接\n         InputStream is = socket.getInputStream();\n\n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n         byte[] buffer2 =new byte[1024];\n         int len2;\n         while ((len2 = is.read(buffer2)) != -1){\n             baos.write(buffer2,0,len2);\n         }\n         System.out.println(baos.toString());\n         //关闭资源 (后创建先关闭原则)\n         baos.close();\n         is.close();\n         fis.close();\n         os.close();\n         socket.close();\n     }\n</code></pre>\n</li>\n</ul>\n<h2 id=\"7、UDP实现消息的发送\"><a href=\"#7、UDP实现消息的发送\" class=\"headerlink\" title=\"7、UDP实现消息的发送\"></a>7、UDP实现消息的发送</h2><hr>\n<ul>\n<li><p><strong>客户端</strong></p>\n<pre><code class=\"lang-java\"> public static void main(String[] args) throws Exception {\n         //建立一个socket\n         DatagramSocket socket = new DatagramSocket();\n         //建立数据包\n         String msg = &quot;Hello,Server!&quot;;\n         //发送目的地\n         InetAddress localhost = InetAddress.getByName(&quot;localhost&quot;);\n         int port =9090;\n         //数据，数据长度的起始，目的地信息\n         DatagramPacket packet = new DatagramPacket(msg.getBytes(), 0, msg.getBytes().length, localhost, port);\n         //发送包\n         socket.send(packet);\n         //关闭流\n         socket.close();\n\n     }\n</code></pre>\n</li>\n</ul>\n<ul>\n<li><p><strong>服务端</strong></p>\n<pre><code class=\"lang-java\"> public static void main(String[] args) throws Exception {\n         //开放端口\n         DatagramSocket socket = new DatagramSocket(9090);\n         //接收数据包\n         byte[] buffer = new byte[1024];\n         DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);\n         //接收包\n         socket.receive(packet);\n         //打印输出目的端地址及数据内容\n         System.out.println(packet.getAddress().getHostName());\n         System.out.println(new String(packet.getData(), 0, packet.getLength()));\n         //关闭流\n         socket.close();\n     }\n</code></pre>\n</li>\n</ul>\n<h2 id=\"8、UDP实现循环发送\"><a href=\"#8、UDP实现循环发送\" class=\"headerlink\" title=\"8、UDP实现循环发送\"></a>8、UDP实现循环发送</h2><hr>\n<ul>\n<li><p><strong>Sender端</strong></p>\n<p> ```java<br>  public static void main(String[] args) throws Exception {</p>\n<pre><code>     //建立端口\n     DatagramSocket socket = new DatagramSocket(8888);\n\n     //数据,通过控制台输入数据\n     BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n</code></pre></li>\n</ul>\n<pre><code>       while (true){\n           String data =  reader.readLine();\n           byte[] datas = data.getBytes();\n\n           DatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(&quot;localhost&quot;,6666));\n\n           socket.send(packet);\n\n           if (data.equals(&quot;bye&quot;)){\n               break;\n           }\n       }\n\n       socket.close();\n   }\n</code></pre><pre><code>\n\n\n+ **Receive端**\n\n   ```java\n   public static void main(String[] args) throws Exception {\n           DatagramSocket socket = new DatagramSocket(6666);\n           while (true){\n\n               byte[] container = new byte[1024];\n               DatagramPacket packet = new DatagramPacket(container, 0, container.length);\n               //阻塞式接收\n               socket.receive(packet);\n\n               byte[] data = packet.getData();\n               String receiveData = new String(data, 0, data.length);\n               System.out.println(receiveData);\n\n               if (receiveData.equals(&quot;bye&quot;)){\n                   break;\n               }\n\n           }\n           //关闭流\n           socket.close();\n       }\n</code></pre><ul>\n<li>实际示例：<ul>\n<li>在线咨询：通信双方既是发送方，也是接收方</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "Java"
            ]
        }
    ]
}