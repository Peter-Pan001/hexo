



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/my-blog/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/my-blog/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="理 想 净 土" href="https://peter-pan001.github.io/my-blog/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="理 想 净 土" href="https://peter-pan001.github.io/my-blog/atom.xml" />
<link rel="alternate" type="application/json" title="理 想 净 土" href="https://peter-pan001.github.io/my-blog/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/my-blog/css/app.css?v=0.2.4">

  
  <meta name="keywords" content="算法与数据结构" />


<link rel="canonical" href="https://peter-pan001.github.io/my-blog/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/">



  <title>
算法入门教程 - 算法与数据结构 |
Peter Pan = 理 想 净 土 =  凭时间赢来的东西，时间肯定会为之作证 </title>
<meta name="generator" content="Hexo 4.2.1"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">算法入门教程
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2021-04-12 19:47:39">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2021-04-12T19:47:39+08:00">2021-04-12</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/my-blog/" rel="start">Peter Pan</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="https://z3.ax1x.com/2021/04/12/cD0fOJ.jpg">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/my-blog/">首页</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/my-blog/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="item" rel="index" title="分类于 算法与数据结构"><span itemprop="name">算法与数据结构</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="https://peter-pan001.github.io/my-blog/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/my-blog/images/avatar.jpg">
    <meta itemprop="name" content="Peter Pan">
    <meta itemprop="description" content=" 凭时间赢来的东西，时间肯定会为之作证 , 不必匆忙，不必火花四溅，不必成为别人，只需成为自己">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="理 想 净 土">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="算法入门"><a href="#算法入门" class="headerlink" title="算法入门"></a>算法入门</h1><h2 id="初识算法"><a href="#初识算法" class="headerlink" title="初识算法"></a>初识算法</h2><ul>
<li>算法是最初为了解决数学上的问题，由于计算机编程与数学密切相关，因此算法也被广泛应用于计算机领域中。</li>
<li>通过学习算法，可以更好地了解计算机底层的实现原理，对各程序有更加深刻的认识。</li>
<li>算法可以帮助我们设计出更好的程序，优化程序的性能，对就职面试也有很大的帮助</li>
</ul>
<h2 id="算法的意义"><a href="#算法的意义" class="headerlink" title="算法的意义"></a>算法的意义</h2><ul>
<li>算法是把人所想的点子（Idea）以编程语言的形式应用到机器或程序设计中</li>
<li>人通过写算法表现自己的程序逻辑与设计方式，而通过编程语言作为载体，让计算机理解人们所要表达的设计逻辑</li>
</ul>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><hr>
<ul>
<li>冒泡排序（bubble Sort），是一种较简单的排序算法</li>
<li>给定一组随机乱序的数组序列，通过比较相邻两个数的大小，按照从小到大的顺序 ，若前者比后者大，则交换位置，否则不需要；当经过一次循环迭代时，出现最大的数在该数组序列的末尾，此时已筛选出最大的数，即“浮出水面”，通过这种比较循环迭代的方式，类似于气泡浮出水面的形式，称为“冒泡”，这种方法也称“冒泡法”。</li>
</ul>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><ul>
<li><strong>详细步骤</strong><ol>
<li>对于给定的一个乱序的随机数组序列，比较相邻两个数，若前者比后者大，则交换。</li>
<li>一轮循环后，出现最大的数，该数则跳出比较循环（根据此规律，每执行完一次循环，就会出现一个排好的数）</li>
<li>重复执行步骤一，直到所有数字从小到大排列完成</li>
</ol>
</li>
</ul>
<h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><pre><code class="lang-java">import java.util.Arrays;

public class BubbleSort {

    public static void main(String[] args) {

        //初始化需要排序的数组
        int array[] = {9,2,11,7,12,5};

        //对需要排序的数组进行排序
        for (int i=1; i&lt;array.length; i++){

            //针对待排序序列中除了已经排序好的元素之外，重复排序工作
            for(int j=0;j&lt;array.length-i;j++){

                //当相邻两个元素需要交换时，交换相邻的两个元素
                if(array[j]&gt;array[j+1]){
                    int temp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = temp;
                }
            }
        }
        //打印出排序好的序列
        System.out.println(Arrays.toString(array));
    }

}
</code></pre>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><hr>
<ul>
<li>插入排序（Insert Sort），是一种较为简单的排序算法</li>
<li>通过构建有序序列，对未排序的序列进行排序，有点类似于打扑克捋顺牌</li>
</ul>
<h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><ul>
<li><strong>详细步骤</strong><ol>
<li>对于一个未排序的数组序列，选取第一个元素，该元素即被认定为已排序的，将该元素放入一个新的序列中，此序列存放排好数的序列</li>
<li>把未排序的数组序列的第二个元素选取出来，对新数列的元素进行大小对比，从大到小排列</li>
<li>后面的数重复进行步骤二</li>
<li>直到旧数列的数全部被选到新序列中，此时的新序列则为排序好的序列</li>
</ol>
</li>
</ul>
<h4 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h4><pre><code class="lang-java">import java.util.Arrays;

public class InsertSort {

    public static void main(String[] args) {
        //初始化需要排序的数组
        int array[] = {9, 2, 11, 7, 12, 5};

        //初始化一个与待排序数组大小相同的数组，用来存放排序好的序列
        int sortArray[] = new int[array.length];

        //步骤1：待排序数组中选择第一个元素作为已经排序好的元素（数组的下标0表示第一个元素）
        sortArray[0] = array[0];

        //步骤2：依次遍历未排序的元素，将其插入已排序序列中
        for (int i = 1; i &lt; array.length; i++) {
            //待排序元素
            int temp = array[i];
            //记录待排序元素需要插入已排序数组中的位置
            int index = i;
            //从已排序好的数组右边依次遍历数组，直到找到待排序元素需要插入的位置
            while(  index &gt; 0  &amp;&amp; temp &lt; sortArray[index-1] ){
                sortArray[index] = sortArray[index-1];
                index--;
            }
            //插入待排序元素
            sortArray[index] = temp;
        }

        //打印出排序好的序列
        System.out.println(Arrays.toString(sortArray));
    }

}
</code></pre>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><hr>
<ul>
<li>选择排序（Select Sort），一种较为直观的排序算法，具有存储空间小的特点</li>
<li>通过对一个未排序的序列进行筛选，每次对整个序列进行筛选，筛选出最小的数，直到把所有的数都筛选完，即可得出最终的正确顺序</li>
<li>选择排序的==主要优点与数据移动有关==。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多$(n-1)$次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</li>
</ul>
<h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><ul>
<li><p><strong>详细步骤</strong></p>
<ol>
<li>一个未排序的序列，对整个序列进行数与数之间的比较，筛选出该序列中最小的数</li>
<li>把筛选出的最小数与该序列的第一个元素的位置进行互换，此时序列的最小数就被选择到了序列的最前面</li>
<li>每次循环迭代都会选出一个未排序序列中的最小数</li>
<li>重复步骤1和2，得出最终的序列即为正确排序的序列（不需要开辟新的地址空间来存储新序列！！！）</li>
</ol>
</li>
<li><p><strong>选出最小数的关键伪代码</strong></p>
<pre><code class="lang-java"> //待排序的序列记为A，寻找最小元素的伪代码如下：
 min = A[0]
 for(int i=1;i&lt;A.length;i++){
    if(A[i] &lt; min){
      min = A[i]
    }
 }
</code></pre>
</li>
</ul>
<h4 id="Java实现-1"><a href="#Java实现-1" class="headerlink" title="Java实现"></a>Java实现</h4><pre><code class="lang-java">import java.util.Arrays;

public class SelectSort {

    public static void main(String[] args) {
        //初始化需要排序的数组
        int array[] = {9, 2, 11, 7, 12, 5};

        //依次进行选择排序，每次找出最小的元素，放入待排序的序列中
        for(int i=0;i&lt;array.length;i++){

            //记录最小元素min和最小元素的数组下标索引minIndex
            int min = array[i];
            int minIndex = i;

            //在未排序的序列中找出最小的元素和对应数组中的位置
            for(int j=i+1;j&lt;array.length;j++){
                if(array[j] &lt; min){
                    min = array[j];
                    minIndex = j;
                }
            }

            //交换位置
            int temp = array[i];
            array[i] = array[minIndex];
            array[minIndex] = temp;
        }

        //打印出排序好的序列
        System.out.println(Arrays.toString(array));
    }

}
</code></pre>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><hr>
<ul>
<li>希尔排序（Shell Sort），也称为“缩小增量排序”，是插入排序的增强版，优先比较较远距离的元素</li>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<blockquote>
<p>参考资料：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC84Nzc4MTczMQ==">https://zhuanlan.zhihu.com/p/87781731</span></p>
</blockquote>
<h4 id="算法基本思想"><a href="#算法基本思想" class="headerlink" title="算法基本思想"></a>算法基本思想</h4><ul>
<li>设待排序列有n个元素，取一整数gap（$gap&lt;n$）作为间隔，将全部元素分为gap个子序列，所有距离为gap的元素放在同一个子序列中</li>
<li>在每一个子序列中分别采用直接插入排序</li>
<li>然后缩小间隔gap，例如取$gap=\frac{gap}{2}$ ,重复上述的子序列划分和排序工作</li>
</ul>
<h4 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h4><ul>
<li><strong>详细步骤</strong><ol>
<li>对于一个未排序的序列，首先对该序列进行“粗略排序”，例如取该序列元素个数的一半作为两个数的跨度（gap），即若元素个数为12，则$gap=6$，每跨越6个数进行两数比较（一号元素与六号元素，二号对七号……），然后两两成组即成了一个个小的子序列，每个子序列进行大小比较，换位后再回到原序列中，此时得到的就是“粗略排序”后的排序序列</li>
<li>接着缩小gap的数值，对“粗略排序”好的序列再进行分组，由于已经进行了“粗略排序”，因此即使子序列的数量因gap值的缩小而增加，也不会花费太长的时间；每个子序列排好序后作为一个整体，进行直接插入排序</li>
<li>重复步骤2，直到出现正确的序列</li>
</ol>
</li>
<li><strong>算法关键点</strong><ul>
<li>该算法对gap值的取值尤为关键</li>
</ul>
</li>
</ul>
<h4 id="Java实现-2"><a href="#Java实现-2" class="headerlink" title="Java实现"></a>Java实现</h4><pre><code class="lang-java">import java.util.Arrays;

public class ShellSort {

    public static void main(String[] args) {

        //初始化需要排序的数组
        int array[] = {9, 2, 11, 7, 12, 5};
        //初始化希尔排序的增量为数组长度
        int gap = array.length;
        //不断地进行插入排序，直至增量为1
        while (true) {
            //增量每次减半
            gap = gap/2;
            for (int i = 0; i &lt; gap; i++) {
                //内部循环是一个插入排序
                for (int j = i + gap; j &lt; array.length; j += gap) {
                    int temp = array[j];
                    int k = j - gap;
                    while (k &gt;= 0 &amp;&amp; array[k] &gt; temp) {
                        array[k + gap] = array[k];
                        k -= gap;
                    }
                    array[k + gap] = temp;
                }
            }
            //增量为1之后，希尔排序结束，退出循环
            if (gap == 1)
                break;
        }
        //打印出排序好的序列
        System.out.println(Arrays.toString(array));
    }

}
</code></pre>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><hr>
<ul>
<li>快速排序（Quick Sort），是一种效率比大多数排序算法都要高的排序算法</li>
<li>快速排序实现的核心思想就是在待排序序列中选择一个基准值，然后将小于基准值的数字放在基准值左边，大于基准值的数字放在基准值右边，然后左右两边递归排序，整个排序过程中最关键部分就是寻找基准值在待排序序列中的索引位置。</li>
</ul>
<h4 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h4><ul>
<li><strong>详细步骤</strong><ol>
<li>给定一个未排序的序列，选取第一个元素作为基准值$key$，使用双指针$i$、$j$的方式，对第二个元素用$i$指向，对最后一个元素用$j$指向，然后$i++$ 直到指向的数比$key$基准值大，此时$i$停止；$j—$直到指向的数比$key$基准值小，此时$j$停止；$i$指向的数与$j$指向的数位置互换，这样，比$key$小的数就会在序列的左边，比$key$大的数就会在序列的右边</li>
<li>在步骤一的$i$与$j$的位置继续进行循环，即$i++$与$j—$，直到出现步骤一的情况，交换两数位置</li>
<li>当$i$与$j$两指针指向同一个数时，该数与基准值$key$交换位置，该数的位置即为基准值的位置，此时 以基准值为界限，分离出两个子序列，左边的子序列的数都比基准值$key$要小，右边的子序列的数都比基准值$key$要大。</li>
<li>接着两个子序列再按照步骤一和步骤二的方法再每个子序列中在分离出两个子序列，此时整个序列有四个小的子序列，当所有序列都按照从小到大的顺序排列时，排序完成</li>
</ol>
</li>
</ul>
<h4 id="Java实现-3"><a href="#Java实现-3" class="headerlink" title="Java实现"></a>Java实现</h4><pre><code class="lang-java">import java.util.Arrays;

public class QuickSort {

    public static void main(String[] args) {
        //初始化需要排序的数组
        int array[] = {9, 2, 11, 7, 12, 5};
        //快速排序
        quickSort(array,0,array.length-1);
        //打印出排序好的序列
        System.out.println(Arrays.toString(array));
    }

    //快速排序
   private static void quickSort(int[] array,int low, int high){
        if(low &lt; high){
            //找到分区的位置，左边右边分别进行快速排序
            int index = partition(array,low,high);
            quickSort(array,0,index-1);
            quickSort(array,index+1,high);
        }
   }

   //快速排序分区操作
   private static int partition(int[] array, int low, int high){
        //选择基准
        int pivot = array[low];
        //当左指针小于右指针时，重复操作
        while (low &lt; high){
            while(low &lt; high &amp;&amp; array[high] &gt;= pivot){
                high = high - 1;
            }
            array[low] = array[high];
            while (low &lt; high &amp;&amp; array[low] &lt;= pivot){
                low = low + 1;
            }
            array[high] = array[low];
        }
        //最后赋值基准
        array[low] = pivot;
        //返回基准所在位置，基准位置已经排序好
        return low;
   }
}
</code></pre>
<h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><hr>
<h3 id="什么是递归？"><a href="#什么是递归？" class="headerlink" title="什么是递归？"></a>什么是递归？</h3><ul>
<li>在数学和计算机领域中，递归主要是指在函数的定义中使用函数自身的方法。顾名思义，递归主要包含两个意思，==递和归==，这个是递归思想的精华所在。递归就是有去（递去）有回（归来）。“有去” 是指递归问题可以分解成若干个规模较小、与原问题形式相同的子问题，这些子问题可以和原问题用相同的方法来求解。“有回” 是指这些问题的演化过程是一个从大到小，并且最终会有一个明确的终点，一旦达到终点，就可以从终点原路返回，解决原问题。</li>
</ul>
<blockquote>
<p>更为直接的说法就是：递归的基本思想就是把大问题转化为相似的小问题解决。特别是在程序中的函数实现时，大问题的解决方案和小问题是一模一样的，所以就产生==解决一个问题会调用函数本身的情况，这个也是递归的定义。==</p>
</blockquote>
<h3 id="递归三要素"><a href="#递归三要素" class="headerlink" title="递归三要素"></a>递归三要素</h3><ol>
<li>递归终止条件———防止出现无限递归</li>
<li>递归终止条件时的处理方法</li>
<li>递归中重复的逻辑提取</li>
</ol>
<pre><code class="lang-java">recursion(big_problem){
   if (end_condition){  //满足递归的终止条件
       solve_end_condition;  //处理终止条件下的逻辑
       end;  //递归结束
   }else {
       recursion(small_problem);  //递归中重复的逻辑提取，缩小问题规模，调用自身方法，即为递归的最明显的特点
   }
}
</code></pre>
<blockquote>
<p>参考文档：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY3h5eGlhb3d1LmNvbS8xMTM1Lmh0bWw=">https://www.cxyxiaowu.com/1135.html</span></p>
</blockquote>
<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><ul>
<li>斐波那契数列（Fibonacci sequence），也称之为黄金分割数列，由意大利数学家列昂纳多・斐波那契（Leonardo Fibonacci）提出。斐波那契数列指的是这样的一个数列：1、1、2、3、5、8、13、21、34、……，这个数列从第 3 项开始，每一项都等于前面两项之和。在数学上，斐波那契数列可以被递推的方法定义如下：</li>
</ul>
<script type="math/tex; mode=display">F(1)=1,F(2)=1,F(n)=F(n-1)+F(n-2) (n\geq3,n\in N^*)</script><h4 id="用Java实现斐波那契数列"><a href="#用Java实现斐波那契数列" class="headerlink" title="用Java实现斐波那契数列"></a>用Java实现斐波那契数列</h4><pre><code class="lang-java">public class Fibonacci {

    public static void main(String[] args){
        System.out.println(fibonacci(1));
        System.out.println(fibonacci(2));
        System.out.println(fibonacci(3));
        System.out.println(fibonacci(4));
        System.out.println(fibonacci(5));
    }

    //斐波那契数列数列的计算
    private static int fibonacci(int n){
        //如果是终止条件，按照要求返回终止条件对应结果
        if( n==1 || n==2 ){
            return 1;
        }else {
            //非终止条件，按照要求把大的问题拆分成小问题，调用自身函数递归处理
            return fibonacci(n-1)+fibonacci(n-2);
        }
    }

}
</code></pre>
<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><hr>
<ul>
<li><strong>分治法</strong>是建基于多项分支递归的一种很重要的算法范型。字面上的解释是“分而治之”，分（divide）是将一个大的问题分解成一些小的问题分别求解，治 （conquer）则是将分解的问题答案合并在一起；即把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</li>
</ul>
<h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><ul>
<li>对于一个规模较大的问题，将其拆分成一个个小的子问题，再对各个小的问题进行求解，最后将所有小问题的结果合并成大问题的解。</li>
</ul>
<h3 id="分治算法的可行性"><a href="#分治算法的可行性" class="headerlink" title="分治算法的可行性"></a>分治算法的可行性</h3><ul>
<li>该问题是否可以拆分成小的问题</li>
<li>每个小的问题能否很容易的解决</li>
</ul>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li>对待求解的问题进行拆分，拆分成一个个小的，相互独立的子问题，形式与待求解问题形式一致</li>
<li>若每个子问题容易求解则直接求解，否则采用递归的方式进行</li>
<li>将各个子问题的解合并成该待求解问题的解</li>
</ol>
<ul>
<li><strong>核心伪代码</strong></li>
</ul>
<pre><code class="lang-java">divideAndConquer(big_problem){
   if (canSolve(big_problem)){ //问题可以直接求解则直接求解返回
       solve(big_problem); //求解
       return; 
   }else {
       small_problem_A = divide(big_problem); //不能直接求解的问题拆分
       small_problem_B = divide(big_problem); //不能直接求解的问题拆分
       divideAndConquer(small_problem_A); //递归求解子问题
       divideAndConquer(small_problem_B); //递归求解子问题
       return merge(); //合并子问题的解
   }
}
</code></pre>
<h3 id="分治法应用场景"><a href="#分治法应用场景" class="headerlink" title="分治法应用场景"></a>分治法应用场景</h3><ul>
<li><strong>二分查找</strong></li>
<li><strong>全排列问题</strong></li>
</ul>
<h3 id="分治算法之最大子数组问题"><a href="#分治算法之最大子数组问题" class="headerlink" title="分治算法之最大子数组问题"></a>分治算法之最大子数组问题</h3><ul>
<li>最大子数组问题描述如下：假如我们有一个数组，数组中的元素有正数和负数，如何在数组中找到一段连续的子数组，使得子数组各个元素之和最大。</li>
</ul>
<blockquote>
<p>最大子数组问题在生活中有很多实际情况可以与其对应，比如说我们观察某一股票在一段时间内的走势，请问如何找出在哪一天买入，哪一天卖出可以赚到最大差价（这里假设你已经知道股票的价格走势）？为了实现最大化的股票收益，我们需要考虑的是买进和卖出时候的价格变化幅度，因此从该股票的每日变化幅度来考虑这个问题更加合适。所以，我们可以将这个问题稍作变形：将股票价格走势对应为每日股票价格涨跌，涨记为正值，跌记为负值，然后一段时间就对应一个正负数数组，并试图找到该数组的最大子数组，就可以获得最大收益。</p>
</blockquote>
<h4 id="分治算法的实现步骤"><a href="#分治算法的实现步骤" class="headerlink" title="分治算法的实现步骤"></a>分治算法的实现步骤</h4><ol>
<li>先找出数组中的中间元素$mid$ ,根据分治策略，把数组分成两个子数组，左边为$[low,mid]$,右边为$[mid+1,high]$</li>
<li>判断最大子数组$[i,j]$的位置，即以下三种情况：<ol>
<li>最大子数组$[i,j]$完全在$[low,mid]$中：即$low\leq i &lt; j \leq mid$</li>
<li>最大子数组$[i,j]$完全在$[mid+1,high]$中：即$mid+1\leq i &lt; j \leq high$</li>
<li>最大子数组$[i,j]$完全在$[low,high]$中：即$low\leq i \leq mid \leq j \leq high$</li>
</ol>
</li>
<li>对三个子问题进行求解</li>
</ol>
<h4 id="Java实现-4"><a href="#Java实现-4" class="headerlink" title="Java实现"></a>Java实现</h4><pre><code class="lang-java">package divide_and_conquer;

public class MaxSubarray {

    //内部类，用来存储最大子数组的返回结果，
    private static class Result {
        int low;
        int high;
        int sum;

        public Result(int low, int high, int sum) {
            this.low = low;
            this.high = high;
            this.sum = sum;
        }

        @Override
        public String toString() {
            return &quot;Result{&quot; +
                    &quot;low=&quot; + low +
                    &quot;, high=&quot; + high +
                    &quot;, sum=&quot; + sum +
                    &#39;}&#39;;
        }
    }

    private static Result FindMaxCrossSubarray(int[]A,int low, int mid, int high){

        //寻找左边的连续最大值及记录位置
        int leftSum = Integer.MIN_VALUE;
        int sum = 0;
        int maxLeft = mid;
        for (int i=mid; i&gt;=low; i--){
            sum = sum + A[i];
            if(sum &gt; leftSum){
                leftSum = sum;
                maxLeft = i;
            }
        }

        //寻找右边的连续最大值及记录位置
        int rightSum = Integer.MIN_VALUE;
        int maxRight = mid+1;
        sum = 0;
        for ( int j=mid+1; j&lt;=high;j++){
            sum = sum + A[j];
            if(sum &gt; rightSum){
                rightSum = sum;
                maxRight = j;
            }
        }

        //返回跨越中间值的最大子数组结果
        return new Result(maxLeft,maxRight,leftSum + rightSum);
    }


    public static  Result FindMaxSubarray(int[] A, int low, int high){
        //数组只有一个元素时的处理情况
        if (high == low){
            return new Result(low,high,A[low]);
        }else {
            //对应思路中步骤1，找到中间元素
            int mid = (low + high)/2;
            //对应思路中步骤2，分别对应a,b,c三种情况求解最大子数组结果
            Result leftResult = FindMaxSubarray(A,low,mid);
            Result rightResult = FindMaxSubarray(A,mid+1,high);
            Result crossResult = FindMaxCrossSubarray(A,low,mid,high);
            //对应步骤3，比较
            if(leftResult.sum &gt;= rightResult.sum &amp;&amp; leftResult.sum &gt;= crossResult.sum){
                return leftResult;
            }else if (rightResult.sum &gt;= leftResult.sum &amp;&amp; rightResult.sum &gt;= crossResult.sum){
                return rightResult;
            }else {
                return crossResult;
            }
        }
    }

    public static void main(String[] args){
        int[] A = {12, -3, -16, 20, -19, -3, 18, 20, -7, 12, -9, 7, -10};
        System.out.println(FindMaxSubarray(A,0,A.length-1).toString());
    }
}
</code></pre>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><hr>
<blockquote>
<p>动态规划通常用于解决最优化问题，在这类问题中，通过做出一组选择来达到最优解。在做出每个选择的同时，通常会生成与原问题形式相同的子问题。当多于一个选择子集都生成相同的子问题时，动态规划技术通常就会很有效，其关键技术就是对每个这样的子问题都保存其解，当其重复出现时即可避免重复求解。</p>
</blockquote>
<ul>
<li>动态规划<code>（Dynamic Programming）</code>在数学上属于运筹学的一个分支，是求解决策过程 <code>（decision process）</code>最优化的数学方法，同时也是计算机科学与技术领域中一种常见的算法思想。</li>
<li>动态规划算法与我们前面提及的分治算法相似，都是==通过组合子问题的解来求解原问题的解==。但是两者之间也有很大区别：<ul>
<li>分治法将问题划分为互不相交的子问题，递归的求解子问题，再将他们的解组合起来求解原问题的解；与之相反，动态规划应用于子问题相互重叠的情况，在这种情况下，分治法还是会做很多重复的不必要的工作，他会反复求解那些公共的子问题，而动态规划算法则对相同的每个子问题只会求解一次，将其结果保存起来，避免一些不必要的计算工作。</li>
</ul>
</li>
</ul>
<h3 id="钢条切割问题"><a href="#钢条切割问题" class="headerlink" title="钢条切割问题"></a>钢条切割问题</h3><ul>
<li><p>某个钢材公司购买长钢条，将其切割为短钢条出售，其中切割过程本身不考虑成本，公司管理层想知道最赚钱的钢材切割方案。假设我们知道该钢材公司出售一段长度为 i 米的钢条的价格为 $p(i)$ ，对应的价目表如下：</p>
<p>|i        |1    |2    |3    |4    |5    |6    |7    |8    |9    |10|<br>|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|<br>|p(i)    |1    |5    |8    |9    |10    |17    |17    |20    |24    |30|</p>
</li>
<li><p>所以，钢材切割问题的定义如下：当我们给定一段长度为 $n$ 米的钢条和对应的一个价格表（ $p(i)$, i = 1,2,3,…n)，求一个钢条切割方案，使得最终的销售收益 $r(n)$ 最大。注意：如果长度为 $n$ 英尺的钢条的价格 $p_n$  足够大，那么最优解就是不需要切割。（在这里，我们要求切割的钢条必须为整米长度）</p>
</li>
<li><p><strong>问题分析</strong> ：考虑  = 4 的情况，那么有以下几种切割方式：</p>
<ol>
<li><p>切割为四段，长度为：1，1，1，1；总共卖$4×1=4$元。</p>
</li>
<li><p>切割为三段，长度为：1，1，2；总共卖$2×1+1×5=7$元。</p>
</li>
<li><p>切割为两段，长度为：1，3；总共卖$1×1+1×8=9$元。</p>
</li>
<li><p>切割为两段，长度为：2，2；总共卖$2×5=10$元。</p>
</li>
<li><p>不切割，长度为：4；总共卖$1×9=9$元。</p>
<p><img data-src="https://z3.ax1x.com/2021/04/12/cDHnsJ.jpg" alt=""></p>
</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li>长度为 $n$ 的钢条，总共有 $2^{n-1}$ 种不同的切割方案，因为长度为 $n$ 的钢条，总共有 $n-1$ 个缝隙，每个缝隙都可以选择切或不切，==所以有 $2^{n-1}$  种不同切割方案。所以随着 $n$ 增大，切割方案总数呈指数级上升，遍历是不现实的==。在这里，很容易想到，当要分析长度为 $n$ 的钢条的最优解时，可以先将钢条切成两段。==将长度为 $n$ 的钢条随意切割的方案是 $2^{n-1}$ 种，但是只切两段的方案只有 $n-1$ 种，这样规避了指数级计算量==。将切成的两段，分别再当作子问题去求解，这就是如下分治策略解法：</li>
</ul>
<h4 id="自顶向下递归实现"><a href="#自顶向下递归实现" class="headerlink" title="自顶向下递归实现"></a>自顶向下递归实现</h4><pre><code class="lang-java">  int CutRod(const int *p, int n)
{
    if (n == 0)
    {
        return 0;
    }

    int q = -1;
    for (int i = 1; i &lt;= n; ++i)
    {
        int tmp = p[i] + CutRod(p, n - i);
        if (q &lt; tmp)
        {
            q = tmp;
        }
    }

    return q;
}
</code></pre>
<ul>
<li>自顶向下递归实现的<code>CutRod</code>效率很差，原因在于<code>CutRod</code>反复地用相同的参数值对自身进行递归调用，即它反复求解相同的子问题。它的运行时间为$T(n)=2^n$。对于长度为n的钢条<code>CutRod</code>考察了所有$2^{n-1}$种可能的切割方案。递归调用树共有$2^{n-1}$个叶结点，每个叶结点对应一种可能的切割方案。</li>
</ul>
<h4 id="动态规划算法一：带备忘录的自顶向下法"><a href="#动态规划算法一：带备忘录的自顶向下法" class="headerlink" title="动态规划算法一：带备忘录的自顶向下法"></a>动态规划算法一：带备忘录的自顶向下法</h4><pre><code class="lang-java">    int MemoizedCutRodAux(const int *p, int n, int *r)
    {
        if (r[n] &gt;= 0)
        {
            return r[n];            //首先检查所需的值是否存在
        }

        int q = -1;
        if (n == 0)
        {
            q = 0;
        }
        else
        {
            for (int i = 1; i &lt;= n; ++i)
            {
                int tmp = p[i] + MemoizedCutRodAux(p, n - i, r);
                if (q &lt; tmp)
                {
                    q = tmp;
                }
            }
        }
        r[n] = q;

        return q;
    }

    int MemoizedCutRod(const int *p, int n)
    {
        int *r = new int[n + 1];
        for (int i = 0; i &lt;= n; ++i)
        {
            r[i] = -1;
        }

        return MemoizedCutRodAux(p, n, r);
    }
</code></pre>
<ul>
<li><p>上述代码与分治不同的地方在于初始化了数组<code>r[n]</code>，将不同长度的最优解数值，储存在了该数组中，所以当不同的 $n$ 传进来时，如果在数组 $r$ 中有当前钢条长度的记录（<code>if r[n] &gt;= 0 : return r[n]</code>)，则直接返回结果，不再进行之后的计算，其余的递归思路与分治策略完全一样。此方法的时间复杂度为 $O(n^2)$  ，变为了多项式时间复杂度。可见，==动态规划算法用少量的空间，显著提升了算法效率。==</p>
</li>
<li><p>自顶向下的动态规划算法，仍然不是最理想的。例如在计算 $n =4 $时， $n = 0 $的情况被计算了8次，采用了备忘录的形式之后，虽然 $n = 0$  的情况只需要计算1次，查表有7次操作，但是这7次查表操作，都是在进入了一个相同的函数中，会有频繁的递归函数调用的开销。采用自底向上的动态规划算法，就可以规避这个问题。</p>
</li>
</ul>
<h4 id="动态规划算法二：自底而上法"><a href="#动态规划算法二：自底而上法" class="headerlink" title="动态规划算法二：自底而上法"></a>动态规划算法二：自底而上法</h4><pre><code class="lang-java">int BottomUpCutRod(const int *p, int n)
{
    int *r = new int[n + 1];
    r[0] = 0;

    for (int i = 1; i &lt;= n; ++i)
    {
        int q = -1;
        for (int j = 1; j &lt;= i; ++j)
        {
            int tmp = p[j] + r[i - j];
            q = q &gt; tmp ? q : tmp;
        }
        r[i] = q;
    }

    return r[n];
}
</code></pre>
<ul>
<li><p>自底向上法不再使用函数递归调用，而采用子问题的自然顺序。在切割时，先由最小的1开始切割，若 $i&lt;j$ ，则规模为 $j$ 的解中一定包含了规模为 $i$ 的全部解（此时子问题的规模，可以理解为之前递归函数的输入 $n$ ）。</p>
</li>
<li><p>上述代码中，仍然先初始化一个数组 $r$  ，用于记录不同规模子问题的最优解，并且将 <code>r[0]</code>  初始化为 0 ；之后对 $j = 1，2，… ，n$进行升序求解。不同于之前算法的是，此时直接访问 <code>r[j-i]</code> 来获得规模为 $j-i$ 的子问题的解。因为自底向上求解时，若 $i&lt;j$，当在求解规模为 $j$ 的子问题时， <code>r[i]</code> 一定有数值，因为之前一定已经计算过。</p>
</li>
<li><p>自底向上算法的时间复杂度也为，但是避免了大量的递归函数调用的开销，算法更加稳定。</p>
</li>
</ul>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><ul>
<li>贪心算法（<code>greedy algorithm</code>）是在对问题求解时，总是做出在当前看来是最好的选择。也就是说，==不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解==。</li>
<li>贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。————摘自Wikipedia</li>
</ul>
<blockquote>
<p>贪心算法与动态规划算法的最大区别在于：贪心算法每次选择的时候都是按照贪心策略来选择的，满足当前情况的最优解，但是并不一定会是整体最优解；动态规划算法在选择考虑时会考虑所有的子情况，选择最优解，这会是整体的最优解。</p>
</blockquote>
<h3 id="关键与实现过程"><a href="#关键与实现过程" class="headerlink" title="关键与实现过程"></a>关键与实现过程</h3><ul>
<li><strong>关键</strong><ol>
<li>创建数学模型来描述问题。</li>
<li>把求解的问题分成若干个子问题。</li>
<li>对每一子问题求解，得到子问题的局部最优解。</li>
<li>把子问题的解局部最优解合成原来解问题的一个解。</li>
</ol>
</li>
<li><strong>实现该算法的过程</strong><ul>
<li>从问题的某一初始解出发；<code>while</code> 能朝给定总目标前进一步 <code>do</code>，求出可行解的一个解元素；最后，由所有解元素组合成问题的一个可行解。</li>
</ul>
</li>
</ul>
<h3 id="贪心算法的可行条件"><a href="#贪心算法的可行条件" class="headerlink" title="贪心算法的可行条件"></a>贪心算法的可行条件</h3><ol>
<li><p><strong>贪心选择</strong> ： 当某一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且每次做出的选择可以依赖以前做出的选择，但不需要依赖后面需要做出的选择。这就是贪心选择性质。对于一个具体问题，要确定它是否具有贪心选择性质，必须==证明每一步所作的贪心选择最终导致问题的整体最优解==。</p>
</li>
<li><p><strong>最优子结构</strong> ： 如果一个问题的最优解包含其子问题的最优解，则此问题具备最优子结构的性质。问题的最优子结构性质是该问题是否可以用贪心算法求解的关键所在。<br>贪心算法与动态规划算法求解的问题类似，都需要满足最优子结构的性质。</p>
</li>
</ol>
<h3 id="贪心算法之分饼干"><a href="#贪心算法之分饼干" class="headerlink" title="贪心算法之分饼干"></a>贪心算法之分饼干</h3><ul>
<li><strong>题目概述</strong><ul>
<li>有一群孩子和一堆饼干，每个孩子有一个饥饿度，每个饼干都有一个大小。每个孩子只能吃最多一个饼干，且只有饼干的大小大于孩子的饥饿度时，这个孩子才能吃饱。求解最多有多少孩子可以吃饱。</li>
</ul>
</li>
<li><p><strong>输入输出样例</strong></p>
<ul>
<li>输入两个数组，分别代表孩子的饥饿度和饼干的大小。输出最多有多少孩子可以吃饱的数量。</li>
</ul>
<pre><code class="lang-yml">Input: [1,2],[1,2,3]
Output: 2
</code></pre>
<ul>
<li>在这个样例中，我们可以给两个孩子喂 <code>[1,2]、[1,3]、[2,3]</code> 这三种组合的任意一种。</li>
</ul>
</li>
<li><strong>题解</strong><ul>
<li>因为饥饿度最小的孩子最容易吃饱，所以我们先考虑这个孩子。为了尽量使得剩下的饼干可以满足饥饿度更大的孩子，所以我们应该把大于等于这个孩子饥饿度的、且大小最小的饼干给这个孩子。满足了这个孩子之后，我们采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，直到没有满足条件的饼干存在。</li>
<li>简而言之，这里的贪心策略是，给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干。至于具体实现，因为我们需要获得大小关系，一个便捷的方法就是把孩子和饼干分别排序。这样我们就可以从饥饿度最小的孩子和大小最小的饼干出发，计算有多少个对子可以满足条件。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>排列组合遍历</strong><pre><code class="lang-java">class Solution {
  public int findContentChildren(int[] g, int[] s) {
      Arrays.sort(g); //孩子饥饿度数组
      Arrays.sort(s); //饼干大小数组
      int numOfChildren = g.length, numOfCookies = s.length;
      int count = 0;
      for (int i = 0, j = 0; i &lt; numOfChildren &amp;&amp; j &lt; numOfCookies; i++, j++) {
          while (j &lt; numOfCookies &amp;&amp; g[i] &gt; s[j]) {
              j++;
          }
          if (j &lt; numOfCookies) {
              count++;
          }
      }
      return count;
  }
}
</code></pre>
</li>
</ul>
<hr>
<ul>
<li><strong>贪心策略</strong><pre><code class="lang-java">public int findContentChildren(int[] grid, int[] size) {
  if (grid == null || size == null) return 0;
  Arrays.sort(grid);
  Arrays.sort(size);
  int gi = 0, si = 0;
  while (gi &lt; grid.length &amp;&amp; si &lt; size.length) {
      if (grid[gi] &lt;= size[si]) {
          gi++;
      }
      si++;
  }
  return gi;
}
</code></pre>
</li>
</ul>
<h3 id="贪心算法之分糖果"><a href="#贪心算法之分糖果" class="headerlink" title="贪心算法之分糖果"></a>贪心算法之分糖果</h3><ul>
<li><strong>题目概述</strong><ul>
<li>一群孩子站成一排，每一个孩子有自己的评分。现在需要给这些孩子发糖果，规则是如果一个孩子的评分比自己身旁的一个孩子要高，那么这个孩子就必须得到比身旁孩子更多的糖果；所有孩子至少要有一个糖果。求解最少需要多少个糖果。</li>
</ul>
</li>
<li><p><strong>输入输出样例</strong></p>
<ul>
<li>输入是一个数组，表示孩子的评分。输出是最少糖果的数量。</li>
</ul>
<pre><code class="lang-yml">Input: [1,0,2]
Output: 5
</code></pre>
<ul>
<li>在这个样例中，最少的糖果分法是 <code>[2,1,2]</code>。</li>
</ul>
</li>
<li><p><strong>题解</strong></p>
<ul>
<li>我们只需要简单的两次遍历即可：把所有孩子的糖果数初始化为 1；先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1；再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1。通过这两次遍历，分配的糖果就可以满足题目要求了。这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一侧的大小关系。</li>
<li>在样例中，我们初始化糖果分配为<code>[1,1,1]</code>，第一次遍历更新后的结果为 <code>[1,1,2]</code>，第二次遍历更新后的结果为<code>[2,1,2]</code>。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>二次遍历代码</strong><pre><code class="lang-java">class Solution {
  public int candy(int[] ratings) {
      int n = ratings.length;
      int[] left = new int[n];
      for (int i = 0; i &lt; n; i++) {
          if (i &gt; 0 &amp;&amp; ratings[i] &gt; ratings[i - 1]) {
              left[i] = left[i - 1] + 1;
          } else {
              left[i] = 1;
          }
      }
      int right = 0, ret = 0;
      for (int i = n - 1; i &gt;= 0; i--) {
          if (i &lt; n - 1 &amp;&amp; ratings[i] &gt; ratings[i + 1]) {
              right++;
          } else {
              right = 1;
          }
          ret += Math.max(left[i], right);
      }
      return ret;
  }
}
</code></pre>
</li>
</ul>
<hr>
<ul>
<li><strong>贪心策略代码</strong><pre><code class="lang-java">class Solution {
  public int candy(int[] ratings) {
      int[] left = new int[ratings.length];
      int[] right = new int[ratings.length];
      Arrays.fill(left, 1);
      Arrays.fill(right, 1);
      for(int i = 1; i &lt; ratings.length; i++)
          if(ratings[i] &gt; ratings[i - 1]) left[i] = left[i - 1] + 1;
      int count = left[ratings.length - 1];
      for(int i = ratings.length - 2; i &gt;= 0; i--) {
          if(ratings[i] &gt; ratings[i + 1]) right[i] = right[i + 1] + 1;
          count += Math.max(left[i], right[i]);
      }
      return count;
  }
}
</code></pre>
</li>
</ul>

      <div class="tags">
          <a href="/my-blog/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="ic i-tag"></i> 算法与数据结构</a>
      </div>
  </div>

   <footer>

    <div class="meta">
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/my-blog/images/wechatpay.png" alt="Peter Pan 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/my-blog/images/alipay.png" alt="Peter Pan 支付宝">
        <p>支付宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>Peter Pan <i class="ic i-at"><em>@</em></i>理 想 净 土
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="https://peter-pan001.github.io/my-blog/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" title="算法入门教程">https://peter-pan001.github.io/my-blog/算法与数据结构/算法入门教程/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/my-blog/%E8%BD%AF%E8%80%83%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s3.ax1x.com&#x2F;2021&#x2F;02&#x2F;17&#x2F;y253bn.jpg" title="网络规划与设计">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> 软考网络工程师</span>
  <h3>网络规划与设计</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/my-blog/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BB%AA%E8%AE%BA/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;z3.ax1x.com&#x2F;2021&#x2F;04&#x2F;12&#x2F;cD0fOJ.jpg" title="数据结构之绪论">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> 算法与数据结构</span>
  <h3>数据结构之绪论</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#算法入门"><span class="toc-number">1.</span> <span class="toc-text">算法入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#初识算法"><span class="toc-number">1.1.</span> <span class="toc-text">初识算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法的意义"><span class="toc-number">1.2.</span> <span class="toc-text">算法的意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序算法"><span class="toc-number">1.3.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#冒泡排序"><span class="toc-number">1.3.1.</span> <span class="toc-text">冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#算法实现"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java代码实现"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">Java代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入排序"><span class="toc-number">1.3.2.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#算法实现-1"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java实现"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">Java实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择排序"><span class="toc-number">1.3.3.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#算法实现-2"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java实现-1"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">Java实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#希尔排序"><span class="toc-number">1.3.4.</span> <span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#算法基本思想"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">算法基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#算法实现-3"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java实现-2"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">Java实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速排序"><span class="toc-number">1.3.5.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#算法实现-4"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java实现-3"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">Java实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归算法"><span class="toc-number">1.4.</span> <span class="toc-text">递归算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是递归？"><span class="toc-number">1.4.1.</span> <span class="toc-text">什么是递归？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归三要素"><span class="toc-number">1.4.2.</span> <span class="toc-text">递归三要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#斐波那契数列"><span class="toc-number">1.4.3.</span> <span class="toc-text">斐波那契数列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用Java实现斐波那契数列"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">用Java实现斐波那契数列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分治算法"><span class="toc-number">1.5.</span> <span class="toc-text">分治算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主要思想"><span class="toc-number">1.5.1.</span> <span class="toc-text">主要思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分治算法的可行性"><span class="toc-number">1.5.2.</span> <span class="toc-text">分治算法的可行性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现步骤"><span class="toc-number">1.5.3.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分治法应用场景"><span class="toc-number">1.5.4.</span> <span class="toc-text">分治法应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分治算法之最大子数组问题"><span class="toc-number">1.5.5.</span> <span class="toc-text">分治算法之最大子数组问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分治算法的实现步骤"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">分治算法的实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java实现-4"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">Java实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态规划"><span class="toc-number">1.6.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#钢条切割问题"><span class="toc-number">1.6.1.</span> <span class="toc-text">钢条切割问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自顶向下递归实现"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">自顶向下递归实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态规划算法一：带备忘录的自顶向下法"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">动态规划算法一：带备忘录的自顶向下法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态规划算法二：自底而上法"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">动态规划算法二：自底而上法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心算法"><span class="toc-number">1.7.</span> <span class="toc-text">贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关键与实现过程"><span class="toc-number">1.7.1.</span> <span class="toc-text">关键与实现过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#贪心算法的可行条件"><span class="toc-number">1.7.2.</span> <span class="toc-text">贪心算法的可行条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#贪心算法之分饼干"><span class="toc-number">1.7.3.</span> <span class="toc-text">贪心算法之分饼干</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#贪心算法之分糖果"><span class="toc-number">1.7.4.</span> <span class="toc-text">贪心算法之分糖果</span></a></li></ol></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li class="active"><a href="/my-blog/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" rel="bookmark" title="算法入门教程">算法入门教程</a></li><li><a href="/my-blog/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BB%AA%E8%AE%BA/" rel="bookmark" title="数据结构之绪论">数据结构之绪论</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="Peter Pan"
      data-src="/my-blog/images/avatar.jpg">
  <p class="name" itemprop="name">Peter Pan</p>
  <div class="description" itemprop="description">不必匆忙，不必火花四溅，不必成为别人，只需成为自己</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/my-blog/archives/">
        <span class="count">69</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/my-blog/categories/">
        <span class="count">10</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/my-blog/tags/">
        <span class="count">14</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1BldGVyLVBhbjAwMS9CYXNpYw==" title="https:&#x2F;&#x2F;github.com&#x2F;Peter-Pan001&#x2F;Basic"><i class="ic i-github"></i></span>
      <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9ndWFuZy1tYW5nLWxpZ2h0bmluZw==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;guang-mang-lightning"><i class="ic i-zhihu"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTE5MjY4NTE4NDA=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1926851840"><i class="ic i-cloud-music"></i></span>
      <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS9QZXRlclBhbjA4MjQ=" title="https:&#x2F;&#x2F;about.me&#x2F;PeterPan0824"><i class="ic i-address-card"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/my-blog/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/my-blog/about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>

        
  <li class="item dropdown">
    <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/my-blog/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/my-blog/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/my-blog/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/my-blog/friends/" rel="section"><i class="ic i-heart"></i>friends</a>
  </li>

    
  <li class="item">
    <a href="/my-blog/links/" rel="section"><i class="ic i-magic"></i>links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/my-blog/%E8%BD%AF%E8%80%83%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/my-blog/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BB%AA%E8%AE%BA/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/my-blog/categories/java/" title="分类于 Java">Java</a>
</div>

    <span><a href="/my-blog/Java/JavaSE%E5%B0%8F%E7%BB%93/" title="JavaSE小结">JavaSE小结</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/my-blog/categories/%E8%BD%AF%E8%80%83%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" title="分类于 软考网络工程师">软考网络工程师</a>
</div>

    <span><a href="/my-blog/%E8%BD%AF%E8%80%83%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/%E7%BD%91%E7%BB%9C%E4%BA%92%E8%81%94%E4%B8%8E%E4%BA%92%E8%81%94%E7%BD%9101/" title="网络互联与互联网01">网络互联与互联网01</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/my-blog/categories/MySQL/" title="分类于 MySQL">MySQL</a>
</div>

    <span><a href="/my-blog/MySQL/%E5%85%B3%E4%BA%8EMySQL%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" title="关于MySQL的一些基本使用">关于MySQL的一些基本使用</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/my-blog/categories/java/" title="分类于 Java">Java</a>
</div>

    <span><a href="/my-blog/Java/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="Java网络编程">Java网络编程</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/my-blog/categories/%E8%BD%AF%E8%80%83%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" title="分类于 软考网络工程师">软考网络工程师</a>
</div>

    <span><a href="/my-blog/%E8%BD%AF%E8%80%83%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E8%AE%BA/" title="计算机基础概论">计算机基础概论</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/my-blog/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 算法与数据结构">算法与数据结构</a>
</div>

    <span><a href="/my-blog/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BB%AA%E8%AE%BA/" title="数据结构之绪论">数据结构之绪论</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/my-blog/categories/java/" title="分类于 Java">Java</a>
</div>

    <span><a href="/my-blog/Java/Java%E5%B0%81%E8%A3%85/" title="Java封装">Java封装</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/my-blog/categories/git/" title="分类于 git">git</a>
</div>

    <span><a href="/my-blog/git/git%E4%B8%8Egithub%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/" title="git与github的基本了解">git与github的基本了解</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/my-blog/categories/Linux/" title="分类于 Linux">Linux</a>
</div>

    <span><a href="/my-blog/Linux/Linux%E5%BC%80%E7%AF%87/" title="Linux开篇">Linux开篇</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/my-blog/categories/%E8%BD%AF%E8%80%83%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/" title="分类于 软考网络工程师">软考网络工程师</a>
</div>

    <span><a href="/my-blog/%E8%BD%AF%E8%80%83%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%92%8C%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/" title="系统开发和项目管理基础">系统开发和项目管理基础</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2020 – 
    <span itemprop="copyrightYear">2022</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Peter Pan @ Peter Pan</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '算法与数据结构/算法入门教程/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/my-blog/js/app.js?v=0.2.4"></script>




</body>
</html>
