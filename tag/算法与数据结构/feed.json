{
    "version": "https://jsonfeed.org/version/1",
    "title": "理 想 净 土 • All posts by \"算法与数据结构\" tag",
    "description": "不必匆忙，不必火花四溅，不必成为别人，只需成为自己",
    "home_page_url": "https://peter-pan001.github.io/my-blog",
    "items": [
        {
            "id": "https://peter-pan001.github.io/my-blog/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BB%AA%E8%AE%BA/",
            "url": "https://peter-pan001.github.io/my-blog/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BB%AA%E8%AE%BA/",
            "title": "数据结构之绪论",
            "date_published": "2021-04-12T11:48:22.000Z",
            "content_html": "<h1 id=\"数据结构之绪论\"><a href=\"#数据结构之绪论\" class=\"headerlink\" title=\"数据结构之绪论\"></a>数据结构之绪论</h1><hr>\n<h2 id=\"数据结构——知识架构\"><a href=\"#数据结构——知识架构\" class=\"headerlink\" title=\"数据结构——知识架构\"></a>数据结构——知识架构</h2><p> <img data-src=\"https://z3.ax1x.com/2021/04/12/cD0qSO.png\" alt=\"\"></p>\n<h3 id=\"什么是数据？\"><a href=\"#什么是数据？\" class=\"headerlink\" title=\"什么是数据？\"></a>什么是数据？</h3><ul>\n<li>是信息的载体，是可以让计算机识别的并处理的符号集合，从底层来说就是一些二进制的0和1。</li>\n</ul>\n<h3 id=\"数据元素与数据项\"><a href=\"#数据元素与数据项\" class=\"headerlink\" title=\"数据元素与数据项\"></a>数据元素与数据项</h3><ul>\n<li>数据的基本单位就是数据元素，多个数据项构成一个数据元素，数据项是数据元素的最小表示单位</li>\n<li><p>但对于现实世界中，评判什么是数据元素与数据项，需要根据具体需求来定义。例如，对于一个学生管理系统，每一个学生的账号就是一个数据元素，而每个学生的性别、年龄、爱好等个人信息就是一个个的数据项，这些数据项构成了学生这个数据元素。</p>\n<p><img data-src=\"https://z3.ax1x.com/2021/04/12/cD0XOH.png\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"数据结构与数据对象\"><a href=\"#数据结构与数据对象\" class=\"headerlink\" title=\"数据结构与数据对象\"></a>数据结构与数据对象</h3><ul>\n<li><p>数据结构是相互具有一种或多种特定关系的数据元素的集合</p>\n</li>\n<li><p>数据对象时具有==相同性质==的数据元素的集合，是数据的子集</p>\n<p> <img data-src=\"https://z3.ax1x.com/2021/04/12/cD0zTI.png\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"数据的逻辑结构\"><a href=\"#数据的逻辑结构\" class=\"headerlink\" title=\"数据的逻辑结构\"></a>数据的逻辑结构</h3><h4 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h4><ul>\n<li>每个元素同属于一个集合</li>\n</ul>\n<h4 id=\"线性结构\"><a href=\"#线性结构\" class=\"headerlink\" title=\"线性结构\"></a>线性结构</h4><ul>\n<li>每个线性结构中只有一个前驱结点，线性结构中的每个数据元素（除了最后一个元素外）都只有唯一的后继结点，相互之间是一对一的关系</li>\n</ul>\n<h4 id=\"树形结构\"><a href=\"#树形结构\" class=\"headerlink\" title=\"树形结构\"></a>树形结构</h4><ul>\n<li>每个树形结构都有一个根结点，每个子节点都只有唯一的父节点，而每个父节点不止一个子节点，相互之间是一对多的关系</li>\n</ul>\n<h4 id=\"图（网）结构\"><a href=\"#图（网）结构\" class=\"headerlink\" title=\"图（网）结构\"></a>图（网）结构</h4><ul>\n<li><p>各个数据元素间都有一定的关系，相互之间是多对多的关系</p>\n<p><img data-src=\"https://z3.ax1x.com/2021/04/12/cDB9tP.png\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"数据的物理结构\"><a href=\"#数据的物理结构\" class=\"headerlink\" title=\"数据的物理结构\"></a>数据的物理结构</h3><h4 id=\"顺序存储\"><a href=\"#顺序存储\" class=\"headerlink\" title=\"顺序存储\"></a>顺序存储</h4><ul>\n<li><p>即逻辑上连续的数据元素在物理内存空间内也必须是连续的内存地址空间来进行存储，元素之间的关系由存储结构的邻接关系所体现</p>\n<p><img data-src=\"https://z3.ax1x.com/2021/04/12/cDBF1S.png\" alt=\"\"></p>\n</li>\n</ul>\n<h4 id=\"链式存储\"><a href=\"#链式存储\" class=\"headerlink\" title=\"链式存储\"></a>链式存储</h4><ul>\n<li><p>在逻辑上相邻的元素可以在物理的存储空间中不相邻，只要用指针来表示各个元素间的逻辑关系即可</p>\n<p><img data-src=\"https://z3.ax1x.com/2021/04/12/cDBk6g.png\" alt=\"\"></p>\n</li>\n</ul>\n<h4 id=\"索引存储\"><a href=\"#索引存储\" class=\"headerlink\" title=\"索引存储\"></a>索引存储</h4><ul>\n<li><p>在内存存储数据元素的同时，再创建索引表通过索引表内的索引项指向内存中的数据元素，形成某种相互关系</p>\n<p><img data-src=\"https://z3.ax1x.com/2021/04/12/cDBnkq.png\" alt=\"\"></p>\n</li>\n</ul>\n<h4 id=\"散列存储\"><a href=\"#散列存储\" class=\"headerlink\" title=\"散列存储\"></a>散列存储</h4><ul>\n<li>根据元素关键字直接计算出该元素所在内存的地址值，又称哈希（hash）存储</li>\n</ul>\n<h3 id=\"数据的运算\"><a href=\"#数据的运算\" class=\"headerlink\" title=\"数据的运算\"></a>数据的运算</h3><ul>\n<li>数据的运算包括数据的定义与实现，定义偏向于逻辑层面，即针对运算的功能；而实现偏向于物理层面，即针对运算的具体步骤</li>\n</ul>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><ul>\n<li>一个值的集合和定义此集合的一组操作的总称</li>\n<li>分为原子类型和结构类型：<ul>\n<li>原子类型：即不可再分的数据类型，例如<code>int</code></li>\n<li>结构类型：其值可以分成若干部分，如一个方法中的各成员变量</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"抽象数据类型\"><a href=\"#抽象数据类型\" class=\"headerlink\" title=\"抽象数据类型\"></a>抽象数据类型</h3><ul>\n<li>用数学化的语言定义的数据逻辑结构</li>\n</ul>\n<h2 id=\"算法——知识架构\"><a href=\"#算法——知识架构\" class=\"headerlink\" title=\"算法——知识架构\"></a>算法——知识架构</h2><p>  <img data-src=\"https://z3.ax1x.com/2021/04/12/cDBQpT.png\" alt=\"\"></p>\n<h3 id=\"什么是算法？\"><a href=\"#什么是算法？\" class=\"headerlink\" title=\"什么是算法？\"></a>什么是算法？</h3><ul>\n<li>程序$=$数据结构$+$算法</li>\n<li>数据结构：即把需求写入计算机中，用计算机可以理解的语言来把需求的信息存进计算机中，并对其结构进行操作</li>\n<li>算法：解决需求的一种方案或方法，处理信息</li>\n</ul>\n<h3 id=\"算法的特性\"><a href=\"#算法的特性\" class=\"headerlink\" title=\"算法的特性\"></a>算法的特性</h3><ul>\n<li><strong>有穷性</strong><ul>\n<li>算法是有穷的，但程序时无穷的</li>\n<li>算法不可以是无限循环，这样的算法是死的，并且在有穷的时间内完成</li>\n</ul>\n</li>\n<li><strong>确定性</strong><ul>\n<li>算法中的每条指令都是有意义的，输入同样的信息必须输出相同的结果</li>\n</ul>\n</li>\n<li><strong>可行性</strong><ul>\n<li>可通过已经实现的有限次运算步骤中实现</li>\n</ul>\n</li>\n<li><strong>有输入</strong><ul>\n<li>一个算法必要要有0或多个输入，数量取决于需求</li>\n</ul>\n</li>\n<li><strong>有输出</strong><ul>\n<li>一个算法必须要有一个或多个输出，不然会死循环！</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"好的算法的特点\"><a href=\"#好的算法的特点\" class=\"headerlink\" title=\"好的算法的特点\"></a>好的算法的特点</h3><ul>\n<li><p><strong>正确性</strong></p>\n<ul>\n<li>必须得出正确的结果</li>\n</ul>\n</li>\n<li><p><strong>可读性</strong></p>\n<ul>\n<li>可以让人们很好的理解算法的实现</li>\n</ul>\n</li>\n<li><p><strong>健壮性</strong></p>\n<ul>\n<li>输入错误数据时，不会输出莫名其妙的数据，而是通过判断来检测出输入数据的正误</li>\n</ul>\n</li>\n<li><p><strong>高效率与低内存</strong></p>\n<ul>\n<li>即执行速度快，时间复杂度低</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"算法效率的度量\"><a href=\"#算法效率的度量\" class=\"headerlink\" title=\"算法效率的度量\"></a>算法效率的度量</h3><h4 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><ul>\n<li>事前预估算法时间开销$T(n)$与问题规模$n$的关系</li>\n<li>它是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。例如，如果一个算法对于任何大小为 <em>n</em> （必须比 $n_0$ 大）的输入，它至多需要 $5n^3 + 3n$ 的时间运行完毕，那么它的渐近时间复杂度是 O($n^3$)。(摘自Wikipedia)</li>\n</ul>\n<h4 id=\"时间复杂度公式-nbsp-算法的渐进时间复杂度\"><a href=\"#时间复杂度公式-nbsp-算法的渐进时间复杂度\" class=\"headerlink\" title=\"时间复杂度公式&nbsp;(算法的渐进时间复杂度)\"></a>时间复杂度公式&nbsp;(算法的渐进时间复杂度)</h4><script type=\"math/tex; mode=display\">T(n)=O(f(n))</script><ul>\n<li><p>其中$f(n)$ 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：==算法的渐进时间复杂度==。</p>\n</li>\n<li><p>例如：</p>\n<pre><code class=\"lang-java\"> for(int i = 0;i &lt;= n;i++){\n     int j = i;\n     j++;\n }\n</code></pre>\n<ul>\n<li>假设每行代码的执行时间都是一样的，我们用$1$颗粒时间 来表示，那么这个例子的第一行耗时是1个颗粒时间，第三行的执行时间是 n个颗粒时间，第四行的执行时间也是 n个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： $T(n) = (1+2n)颗粒时间$，从这个结果可以看出，这个算法的耗时是随着n的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>常见的时间复杂度量级有：</p>\n<ul>\n<li>常数阶 $O(1)$</li>\n<li>对数阶 $O(logN)$</li>\n<li>线性阶 $O(n)$</li>\n<li>线性对数阶 $O(nlogN)$</li>\n<li>平方阶 $O(n^2)$</li>\n<li>立方阶 $O(n^3)$</li>\n<li>K次方阶 $O(n^k)$</li>\n<li>指数阶 $(2^n)$</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"时间复杂度运算\"><a href=\"#时间复杂度运算\" class=\"headerlink\" title=\"时间复杂度运算\"></a>时间复杂度运算</h4><ul>\n<li><p><strong>加法规则</strong></p>\n<script type=\"math/tex; mode=display\">T(n) = T_1(n) + T_2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n)))</script><ul>\n<li>多项相加，只保留最高阶的项，且系数变为1</li>\n</ul>\n</li>\n<li><p><strong>乘法规则</strong></p>\n<script type=\"math/tex; mode=display\">T(n) = T_1(n)×T_2(n) = O(f(n))×O(g(n)) = O(f(n)×g(n))</script><ul>\n<li>多项相乘，全部保留</li>\n</ul>\n</li>\n<li><p><strong>各常见时间复杂度关系</strong></p>\n<script type=\"math/tex; mode=display\">O(1)<O(log_2 n)<O(n)<O(n log_2 n)<O(n^2)<O(2^n)<O(n!)<O(n^n)</script></li>\n<li><p><strong>最坏时间复杂度</strong>:</p>\n<ul>\n<li>最坏情况下算法的时间复杂度</li>\n</ul>\n</li>\n<li><p><strong>平均时间复杂度</strong>:</p>\n<ul>\n<li>所有输入示例等概率出现的情况下,算法的期望运行时间</li>\n</ul>\n</li>\n<li><p><strong>最好时间复杂度</strong>:</p>\n<ul>\n<li>最好情况下算法的时间复杂度</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h4><ul>\n<li><p>无论问题规模怎么变,算法运行所需的内存空间，都是固定的常量,算法空间复杂度为</p>\n<script type=\"math/tex; mode=display\">S(n) = O(1)</script><blockquote>\n<p>注:S表示 “Space”<br>算法原地工作——算法所需内存空间为常量</p>\n</blockquote>\n</li>\n<li><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，因此我们用 S(n) 来定义。</p>\n</li>\n<li><p>$S(n)=O(n)$</p>\n<pre><code class=\"lang-java\"> void arr(int n){\n     int arr1[n];\n     int i;\n }\n</code></pre>\n<ul>\n<li><p>假设一个<code>int</code>类型占<code>4B</code>，则上面的代码占用的内存为：</p>\n<script type=\"math/tex; mode=display\">S(n)=4+4n+4</script></li>\n<li><p><code>i</code>变量占<code>4B</code>，<code>n</code>变量占<code>4B</code>，数组 <code>arr[n]</code>,占<code>4n</code></p>\n</li>\n</ul>\n</li>\n<li><p>$S(n)=O(n^2)$</p>\n<pre><code class=\"lang-java\"> void one_arr(int n){\n     int arr2[n][n];\n     int i;\n }\n</code></pre>\n<ul>\n<li><p>此时上面的代码占用的内存为：</p>\n<pre><code>$$S(n)=n^2+4$$\n</code></pre></li>\n<li><p>简记为：$S(n)=O(n^2)$</p>\n</li>\n</ul>\n</li>\n<li><p>$S(n)=O(n^2)+O(n)+O(1)$</p>\n<pre><code class=\"lang-java\"> void one_arr1(int n){\n     int arr2[n][n];\n     int arr[n]\n     int i;\n }\n</code></pre>\n<ul>\n<li><p>此时上面的代码占用的内存为：</p>\n<script type=\"math/tex; mode=display\">S(n)=O(n^2)+O(n)+O(1)=O(n^2)</script><ul>\n<li>只保留最高指数项</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>参考资料：<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MDQ3OTU1NQ==\">https://zhuanlan.zhihu.com/p/50479555</span></p>\n<p>简书：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9mNGNjYTVjZTA1NWE=\">https://www.jianshu.com/p/f4cca5ce055a</span></p>\n</blockquote>\n",
            "tags": [
                "算法与数据结构"
            ]
        },
        {
            "id": "https://peter-pan001.github.io/my-blog/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/",
            "url": "https://peter-pan001.github.io/my-blog/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/",
            "title": "算法入门教程",
            "date_published": "2021-04-12T11:47:39.000Z",
            "content_html": "<h1 id=\"算法入门\"><a href=\"#算法入门\" class=\"headerlink\" title=\"算法入门\"></a>算法入门</h1><h2 id=\"初识算法\"><a href=\"#初识算法\" class=\"headerlink\" title=\"初识算法\"></a>初识算法</h2><ul>\n<li>算法是最初为了解决数学上的问题，由于计算机编程与数学密切相关，因此算法也被广泛应用于计算机领域中。</li>\n<li>通过学习算法，可以更好地了解计算机底层的实现原理，对各程序有更加深刻的认识。</li>\n<li>算法可以帮助我们设计出更好的程序，优化程序的性能，对就职面试也有很大的帮助</li>\n</ul>\n<h2 id=\"算法的意义\"><a href=\"#算法的意义\" class=\"headerlink\" title=\"算法的意义\"></a>算法的意义</h2><ul>\n<li>算法是把人所想的点子（Idea）以编程语言的形式应用到机器或程序设计中</li>\n<li>人通过写算法表现自己的程序逻辑与设计方式，而通过编程语言作为载体，让计算机理解人们所要表达的设计逻辑</li>\n</ul>\n<h2 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h2><h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><hr>\n<ul>\n<li>冒泡排序（bubble Sort），是一种较简单的排序算法</li>\n<li>给定一组随机乱序的数组序列，通过比较相邻两个数的大小，按照从小到大的顺序 ，若前者比后者大，则交换位置，否则不需要；当经过一次循环迭代时，出现最大的数在该数组序列的末尾，此时已筛选出最大的数，即“浮出水面”，通过这种比较循环迭代的方式，类似于气泡浮出水面的形式，称为“冒泡”，这种方法也称“冒泡法”。</li>\n</ul>\n<h4 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h4><ul>\n<li><strong>详细步骤</strong><ol>\n<li>对于给定的一个乱序的随机数组序列，比较相邻两个数，若前者比后者大，则交换。</li>\n<li>一轮循环后，出现最大的数，该数则跳出比较循环（根据此规律，每执行完一次循环，就会出现一个排好的数）</li>\n<li>重复执行步骤一，直到所有数字从小到大排列完成</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"Java代码实现\"><a href=\"#Java代码实现\" class=\"headerlink\" title=\"Java代码实现\"></a>Java代码实现</h4><pre><code class=\"lang-java\">import java.util.Arrays;\n\npublic class BubbleSort {\n\n    public static void main(String[] args) {\n\n        //初始化需要排序的数组\n        int array[] = {9,2,11,7,12,5};\n\n        //对需要排序的数组进行排序\n        for (int i=1; i&lt;array.length; i++){\n\n            //针对待排序序列中除了已经排序好的元素之外，重复排序工作\n            for(int j=0;j&lt;array.length-i;j++){\n\n                //当相邻两个元素需要交换时，交换相邻的两个元素\n                if(array[j]&gt;array[j+1]){\n                    int temp = array[j];\n                    array[j] = array[j+1];\n                    array[j+1] = temp;\n                }\n            }\n        }\n        //打印出排序好的序列\n        System.out.println(Arrays.toString(array));\n    }\n\n}\n</code></pre>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><hr>\n<ul>\n<li>插入排序（Insert Sort），是一种较为简单的排序算法</li>\n<li>通过构建有序序列，对未排序的序列进行排序，有点类似于打扑克捋顺牌</li>\n</ul>\n<h4 id=\"算法实现-1\"><a href=\"#算法实现-1\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h4><ul>\n<li><strong>详细步骤</strong><ol>\n<li>对于一个未排序的数组序列，选取第一个元素，该元素即被认定为已排序的，将该元素放入一个新的序列中，此序列存放排好数的序列</li>\n<li>把未排序的数组序列的第二个元素选取出来，对新数列的元素进行大小对比，从大到小排列</li>\n<li>后面的数重复进行步骤二</li>\n<li>直到旧数列的数全部被选到新序列中，此时的新序列则为排序好的序列</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"Java实现\"><a href=\"#Java实现\" class=\"headerlink\" title=\"Java实现\"></a>Java实现</h4><pre><code class=\"lang-java\">import java.util.Arrays;\n\npublic class InsertSort {\n\n    public static void main(String[] args) {\n        //初始化需要排序的数组\n        int array[] = {9, 2, 11, 7, 12, 5};\n\n        //初始化一个与待排序数组大小相同的数组，用来存放排序好的序列\n        int sortArray[] = new int[array.length];\n\n        //步骤1：待排序数组中选择第一个元素作为已经排序好的元素（数组的下标0表示第一个元素）\n        sortArray[0] = array[0];\n\n        //步骤2：依次遍历未排序的元素，将其插入已排序序列中\n        for (int i = 1; i &lt; array.length; i++) {\n            //待排序元素\n            int temp = array[i];\n            //记录待排序元素需要插入已排序数组中的位置\n            int index = i;\n            //从已排序好的数组右边依次遍历数组，直到找到待排序元素需要插入的位置\n            while(  index &gt; 0  &amp;&amp; temp &lt; sortArray[index-1] ){\n                sortArray[index] = sortArray[index-1];\n                index--;\n            }\n            //插入待排序元素\n            sortArray[index] = temp;\n        }\n\n        //打印出排序好的序列\n        System.out.println(Arrays.toString(sortArray));\n    }\n\n}\n</code></pre>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><hr>\n<ul>\n<li>选择排序（Select Sort），一种较为直观的排序算法，具有存储空间小的特点</li>\n<li>通过对一个未排序的序列进行筛选，每次对整个序列进行筛选，筛选出最小的数，直到把所有的数都筛选完，即可得出最终的正确顺序</li>\n<li>选择排序的==主要优点与数据移动有关==。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多$(n-1)$次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</li>\n</ul>\n<h4 id=\"算法实现-2\"><a href=\"#算法实现-2\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h4><ul>\n<li><p><strong>详细步骤</strong></p>\n<ol>\n<li>一个未排序的序列，对整个序列进行数与数之间的比较，筛选出该序列中最小的数</li>\n<li>把筛选出的最小数与该序列的第一个元素的位置进行互换，此时序列的最小数就被选择到了序列的最前面</li>\n<li>每次循环迭代都会选出一个未排序序列中的最小数</li>\n<li>重复步骤1和2，得出最终的序列即为正确排序的序列（不需要开辟新的地址空间来存储新序列！！！）</li>\n</ol>\n</li>\n<li><p><strong>选出最小数的关键伪代码</strong></p>\n<pre><code class=\"lang-java\"> //待排序的序列记为A，寻找最小元素的伪代码如下：\n min = A[0]\n for(int i=1;i&lt;A.length;i++){\n    if(A[i] &lt; min){\n      min = A[i]\n    }\n }\n</code></pre>\n</li>\n</ul>\n<h4 id=\"Java实现-1\"><a href=\"#Java实现-1\" class=\"headerlink\" title=\"Java实现\"></a>Java实现</h4><pre><code class=\"lang-java\">import java.util.Arrays;\n\npublic class SelectSort {\n\n    public static void main(String[] args) {\n        //初始化需要排序的数组\n        int array[] = {9, 2, 11, 7, 12, 5};\n\n        //依次进行选择排序，每次找出最小的元素，放入待排序的序列中\n        for(int i=0;i&lt;array.length;i++){\n\n            //记录最小元素min和最小元素的数组下标索引minIndex\n            int min = array[i];\n            int minIndex = i;\n\n            //在未排序的序列中找出最小的元素和对应数组中的位置\n            for(int j=i+1;j&lt;array.length;j++){\n                if(array[j] &lt; min){\n                    min = array[j];\n                    minIndex = j;\n                }\n            }\n\n            //交换位置\n            int temp = array[i];\n            array[i] = array[minIndex];\n            array[minIndex] = temp;\n        }\n\n        //打印出排序好的序列\n        System.out.println(Arrays.toString(array));\n    }\n\n}\n</code></pre>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><hr>\n<ul>\n<li>希尔排序（Shell Sort），也称为“缩小增量排序”，是插入排序的增强版，优先比较较远距离的元素</li>\n<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>\n<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>\n</ul>\n<blockquote>\n<p>参考资料：<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC84Nzc4MTczMQ==\">https://zhuanlan.zhihu.com/p/87781731</span></p>\n</blockquote>\n<h4 id=\"算法基本思想\"><a href=\"#算法基本思想\" class=\"headerlink\" title=\"算法基本思想\"></a>算法基本思想</h4><ul>\n<li>设待排序列有n个元素，取一整数gap（$gap&lt;n$）作为间隔，将全部元素分为gap个子序列，所有距离为gap的元素放在同一个子序列中</li>\n<li>在每一个子序列中分别采用直接插入排序</li>\n<li>然后缩小间隔gap，例如取$gap=\\frac{gap}{2}$ ,重复上述的子序列划分和排序工作</li>\n</ul>\n<h4 id=\"算法实现-3\"><a href=\"#算法实现-3\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h4><ul>\n<li><strong>详细步骤</strong><ol>\n<li>对于一个未排序的序列，首先对该序列进行“粗略排序”，例如取该序列元素个数的一半作为两个数的跨度（gap），即若元素个数为12，则$gap=6$，每跨越6个数进行两数比较（一号元素与六号元素，二号对七号……），然后两两成组即成了一个个小的子序列，每个子序列进行大小比较，换位后再回到原序列中，此时得到的就是“粗略排序”后的排序序列</li>\n<li>接着缩小gap的数值，对“粗略排序”好的序列再进行分组，由于已经进行了“粗略排序”，因此即使子序列的数量因gap值的缩小而增加，也不会花费太长的时间；每个子序列排好序后作为一个整体，进行直接插入排序</li>\n<li>重复步骤2，直到出现正确的序列</li>\n</ol>\n</li>\n<li><strong>算法关键点</strong><ul>\n<li>该算法对gap值的取值尤为关键</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Java实现-2\"><a href=\"#Java实现-2\" class=\"headerlink\" title=\"Java实现\"></a>Java实现</h4><pre><code class=\"lang-java\">import java.util.Arrays;\n\npublic class ShellSort {\n\n    public static void main(String[] args) {\n\n        //初始化需要排序的数组\n        int array[] = {9, 2, 11, 7, 12, 5};\n        //初始化希尔排序的增量为数组长度\n        int gap = array.length;\n        //不断地进行插入排序，直至增量为1\n        while (true) {\n            //增量每次减半\n            gap = gap/2;\n            for (int i = 0; i &lt; gap; i++) {\n                //内部循环是一个插入排序\n                for (int j = i + gap; j &lt; array.length; j += gap) {\n                    int temp = array[j];\n                    int k = j - gap;\n                    while (k &gt;= 0 &amp;&amp; array[k] &gt; temp) {\n                        array[k + gap] = array[k];\n                        k -= gap;\n                    }\n                    array[k + gap] = temp;\n                }\n            }\n            //增量为1之后，希尔排序结束，退出循环\n            if (gap == 1)\n                break;\n        }\n        //打印出排序好的序列\n        System.out.println(Arrays.toString(array));\n    }\n\n}\n</code></pre>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><hr>\n<ul>\n<li>快速排序（Quick Sort），是一种效率比大多数排序算法都要高的排序算法</li>\n<li>快速排序实现的核心思想就是在待排序序列中选择一个基准值，然后将小于基准值的数字放在基准值左边，大于基准值的数字放在基准值右边，然后左右两边递归排序，整个排序过程中最关键部分就是寻找基准值在待排序序列中的索引位置。</li>\n</ul>\n<h4 id=\"算法实现-4\"><a href=\"#算法实现-4\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h4><ul>\n<li><strong>详细步骤</strong><ol>\n<li>给定一个未排序的序列，选取第一个元素作为基准值$key$，使用双指针$i$、$j$的方式，对第二个元素用$i$指向，对最后一个元素用$j$指向，然后$i++$ 直到指向的数比$key$基准值大，此时$i$停止；$j—$直到指向的数比$key$基准值小，此时$j$停止；$i$指向的数与$j$指向的数位置互换，这样，比$key$小的数就会在序列的左边，比$key$大的数就会在序列的右边</li>\n<li>在步骤一的$i$与$j$的位置继续进行循环，即$i++$与$j—$，直到出现步骤一的情况，交换两数位置</li>\n<li>当$i$与$j$两指针指向同一个数时，该数与基准值$key$交换位置，该数的位置即为基准值的位置，此时 以基准值为界限，分离出两个子序列，左边的子序列的数都比基准值$key$要小，右边的子序列的数都比基准值$key$要大。</li>\n<li>接着两个子序列再按照步骤一和步骤二的方法再每个子序列中在分离出两个子序列，此时整个序列有四个小的子序列，当所有序列都按照从小到大的顺序排列时，排序完成</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"Java实现-3\"><a href=\"#Java实现-3\" class=\"headerlink\" title=\"Java实现\"></a>Java实现</h4><pre><code class=\"lang-java\">import java.util.Arrays;\n\npublic class QuickSort {\n\n    public static void main(String[] args) {\n        //初始化需要排序的数组\n        int array[] = {9, 2, 11, 7, 12, 5};\n        //快速排序\n        quickSort(array,0,array.length-1);\n        //打印出排序好的序列\n        System.out.println(Arrays.toString(array));\n    }\n\n    //快速排序\n   private static void quickSort(int[] array,int low, int high){\n        if(low &lt; high){\n            //找到分区的位置，左边右边分别进行快速排序\n            int index = partition(array,low,high);\n            quickSort(array,0,index-1);\n            quickSort(array,index+1,high);\n        }\n   }\n\n   //快速排序分区操作\n   private static int partition(int[] array, int low, int high){\n        //选择基准\n        int pivot = array[low];\n        //当左指针小于右指针时，重复操作\n        while (low &lt; high){\n            while(low &lt; high &amp;&amp; array[high] &gt;= pivot){\n                high = high - 1;\n            }\n            array[low] = array[high];\n            while (low &lt; high &amp;&amp; array[low] &lt;= pivot){\n                low = low + 1;\n            }\n            array[high] = array[low];\n        }\n        //最后赋值基准\n        array[low] = pivot;\n        //返回基准所在位置，基准位置已经排序好\n        return low;\n   }\n}\n</code></pre>\n<h2 id=\"递归算法\"><a href=\"#递归算法\" class=\"headerlink\" title=\"递归算法\"></a>递归算法</h2><hr>\n<h3 id=\"什么是递归？\"><a href=\"#什么是递归？\" class=\"headerlink\" title=\"什么是递归？\"></a>什么是递归？</h3><ul>\n<li>在数学和计算机领域中，递归主要是指在函数的定义中使用函数自身的方法。顾名思义，递归主要包含两个意思，==递和归==，这个是递归思想的精华所在。递归就是有去（递去）有回（归来）。“有去” 是指递归问题可以分解成若干个规模较小、与原问题形式相同的子问题，这些子问题可以和原问题用相同的方法来求解。“有回” 是指这些问题的演化过程是一个从大到小，并且最终会有一个明确的终点，一旦达到终点，就可以从终点原路返回，解决原问题。</li>\n</ul>\n<blockquote>\n<p>更为直接的说法就是：递归的基本思想就是把大问题转化为相似的小问题解决。特别是在程序中的函数实现时，大问题的解决方案和小问题是一模一样的，所以就产生==解决一个问题会调用函数本身的情况，这个也是递归的定义。==</p>\n</blockquote>\n<h3 id=\"递归三要素\"><a href=\"#递归三要素\" class=\"headerlink\" title=\"递归三要素\"></a>递归三要素</h3><ol>\n<li>递归终止条件———防止出现无限递归</li>\n<li>递归终止条件时的处理方法</li>\n<li>递归中重复的逻辑提取</li>\n</ol>\n<pre><code class=\"lang-java\">recursion(big_problem){\n   if (end_condition){  //满足递归的终止条件\n       solve_end_condition;  //处理终止条件下的逻辑\n       end;  //递归结束\n   }else {\n       recursion(small_problem);  //递归中重复的逻辑提取，缩小问题规模，调用自身方法，即为递归的最明显的特点\n   }\n}\n</code></pre>\n<blockquote>\n<p>参考文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3h5eGlhb3d1LmNvbS8xMTM1Lmh0bWw=\">https://www.cxyxiaowu.com/1135.html</span></p>\n</blockquote>\n<h3 id=\"斐波那契数列\"><a href=\"#斐波那契数列\" class=\"headerlink\" title=\"斐波那契数列\"></a>斐波那契数列</h3><ul>\n<li>斐波那契数列（Fibonacci sequence），也称之为黄金分割数列，由意大利数学家列昂纳多・斐波那契（Leonardo Fibonacci）提出。斐波那契数列指的是这样的一个数列：1、1、2、3、5、8、13、21、34、……，这个数列从第 3 项开始，每一项都等于前面两项之和。在数学上，斐波那契数列可以被递推的方法定义如下：</li>\n</ul>\n<script type=\"math/tex; mode=display\">F(1)=1,F(2)=1,F(n)=F(n-1)+F(n-2) (n\\geq3,n\\in N^*)</script><h4 id=\"用Java实现斐波那契数列\"><a href=\"#用Java实现斐波那契数列\" class=\"headerlink\" title=\"用Java实现斐波那契数列\"></a>用Java实现斐波那契数列</h4><pre><code class=\"lang-java\">public class Fibonacci {\n\n    public static void main(String[] args){\n        System.out.println(fibonacci(1));\n        System.out.println(fibonacci(2));\n        System.out.println(fibonacci(3));\n        System.out.println(fibonacci(4));\n        System.out.println(fibonacci(5));\n    }\n\n    //斐波那契数列数列的计算\n    private static int fibonacci(int n){\n        //如果是终止条件，按照要求返回终止条件对应结果\n        if( n==1 || n==2 ){\n            return 1;\n        }else {\n            //非终止条件，按照要求把大的问题拆分成小问题，调用自身函数递归处理\n            return fibonacci(n-1)+fibonacci(n-2);\n        }\n    }\n\n}\n</code></pre>\n<h2 id=\"分治算法\"><a href=\"#分治算法\" class=\"headerlink\" title=\"分治算法\"></a>分治算法</h2><hr>\n<ul>\n<li><strong>分治法</strong>是建基于多项分支递归的一种很重要的算法范型。字面上的解释是“分而治之”，分（divide）是将一个大的问题分解成一些小的问题分别求解，治 （conquer）则是将分解的问题答案合并在一起；即把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</li>\n</ul>\n<h3 id=\"主要思想\"><a href=\"#主要思想\" class=\"headerlink\" title=\"主要思想\"></a>主要思想</h3><ul>\n<li>对于一个规模较大的问题，将其拆分成一个个小的子问题，再对各个小的问题进行求解，最后将所有小问题的结果合并成大问题的解。</li>\n</ul>\n<h3 id=\"分治算法的可行性\"><a href=\"#分治算法的可行性\" class=\"headerlink\" title=\"分治算法的可行性\"></a>分治算法的可行性</h3><ul>\n<li>该问题是否可以拆分成小的问题</li>\n<li>每个小的问题能否很容易的解决</li>\n</ul>\n<h3 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h3><ol>\n<li>对待求解的问题进行拆分，拆分成一个个小的，相互独立的子问题，形式与待求解问题形式一致</li>\n<li>若每个子问题容易求解则直接求解，否则采用递归的方式进行</li>\n<li>将各个子问题的解合并成该待求解问题的解</li>\n</ol>\n<ul>\n<li><strong>核心伪代码</strong></li>\n</ul>\n<pre><code class=\"lang-java\">divideAndConquer(big_problem){\n   if (canSolve(big_problem)){ //问题可以直接求解则直接求解返回\n       solve(big_problem); //求解\n       return; \n   }else {\n       small_problem_A = divide(big_problem); //不能直接求解的问题拆分\n       small_problem_B = divide(big_problem); //不能直接求解的问题拆分\n       divideAndConquer(small_problem_A); //递归求解子问题\n       divideAndConquer(small_problem_B); //递归求解子问题\n       return merge(); //合并子问题的解\n   }\n}\n</code></pre>\n<h3 id=\"分治法应用场景\"><a href=\"#分治法应用场景\" class=\"headerlink\" title=\"分治法应用场景\"></a>分治法应用场景</h3><ul>\n<li><strong>二分查找</strong></li>\n<li><strong>全排列问题</strong></li>\n</ul>\n<h3 id=\"分治算法之最大子数组问题\"><a href=\"#分治算法之最大子数组问题\" class=\"headerlink\" title=\"分治算法之最大子数组问题\"></a>分治算法之最大子数组问题</h3><ul>\n<li>最大子数组问题描述如下：假如我们有一个数组，数组中的元素有正数和负数，如何在数组中找到一段连续的子数组，使得子数组各个元素之和最大。</li>\n</ul>\n<blockquote>\n<p>最大子数组问题在生活中有很多实际情况可以与其对应，比如说我们观察某一股票在一段时间内的走势，请问如何找出在哪一天买入，哪一天卖出可以赚到最大差价（这里假设你已经知道股票的价格走势）？为了实现最大化的股票收益，我们需要考虑的是买进和卖出时候的价格变化幅度，因此从该股票的每日变化幅度来考虑这个问题更加合适。所以，我们可以将这个问题稍作变形：将股票价格走势对应为每日股票价格涨跌，涨记为正值，跌记为负值，然后一段时间就对应一个正负数数组，并试图找到该数组的最大子数组，就可以获得最大收益。</p>\n</blockquote>\n<h4 id=\"分治算法的实现步骤\"><a href=\"#分治算法的实现步骤\" class=\"headerlink\" title=\"分治算法的实现步骤\"></a>分治算法的实现步骤</h4><ol>\n<li>先找出数组中的中间元素$mid$ ,根据分治策略，把数组分成两个子数组，左边为$[low,mid]$,右边为$[mid+1,high]$</li>\n<li>判断最大子数组$[i,j]$的位置，即以下三种情况：<ol>\n<li>最大子数组$[i,j]$完全在$[low,mid]$中：即$low\\leq i &lt; j \\leq mid$</li>\n<li>最大子数组$[i,j]$完全在$[mid+1,high]$中：即$mid+1\\leq i &lt; j \\leq high$</li>\n<li>最大子数组$[i,j]$完全在$[low,high]$中：即$low\\leq i \\leq mid \\leq j \\leq high$</li>\n</ol>\n</li>\n<li>对三个子问题进行求解</li>\n</ol>\n<h4 id=\"Java实现-4\"><a href=\"#Java实现-4\" class=\"headerlink\" title=\"Java实现\"></a>Java实现</h4><pre><code class=\"lang-java\">package divide_and_conquer;\n\npublic class MaxSubarray {\n\n    //内部类，用来存储最大子数组的返回结果，\n    private static class Result {\n        int low;\n        int high;\n        int sum;\n\n        public Result(int low, int high, int sum) {\n            this.low = low;\n            this.high = high;\n            this.sum = sum;\n        }\n\n        @Override\n        public String toString() {\n            return &quot;Result{&quot; +\n                    &quot;low=&quot; + low +\n                    &quot;, high=&quot; + high +\n                    &quot;, sum=&quot; + sum +\n                    &#39;}&#39;;\n        }\n    }\n\n    private static Result FindMaxCrossSubarray(int[]A,int low, int mid, int high){\n\n        //寻找左边的连续最大值及记录位置\n        int leftSum = Integer.MIN_VALUE;\n        int sum = 0;\n        int maxLeft = mid;\n        for (int i=mid; i&gt;=low; i--){\n            sum = sum + A[i];\n            if(sum &gt; leftSum){\n                leftSum = sum;\n                maxLeft = i;\n            }\n        }\n\n        //寻找右边的连续最大值及记录位置\n        int rightSum = Integer.MIN_VALUE;\n        int maxRight = mid+1;\n        sum = 0;\n        for ( int j=mid+1; j&lt;=high;j++){\n            sum = sum + A[j];\n            if(sum &gt; rightSum){\n                rightSum = sum;\n                maxRight = j;\n            }\n        }\n\n        //返回跨越中间值的最大子数组结果\n        return new Result(maxLeft,maxRight,leftSum + rightSum);\n    }\n\n\n    public static  Result FindMaxSubarray(int[] A, int low, int high){\n        //数组只有一个元素时的处理情况\n        if (high == low){\n            return new Result(low,high,A[low]);\n        }else {\n            //对应思路中步骤1，找到中间元素\n            int mid = (low + high)/2;\n            //对应思路中步骤2，分别对应a,b,c三种情况求解最大子数组结果\n            Result leftResult = FindMaxSubarray(A,low,mid);\n            Result rightResult = FindMaxSubarray(A,mid+1,high);\n            Result crossResult = FindMaxCrossSubarray(A,low,mid,high);\n            //对应步骤3，比较\n            if(leftResult.sum &gt;= rightResult.sum &amp;&amp; leftResult.sum &gt;= crossResult.sum){\n                return leftResult;\n            }else if (rightResult.sum &gt;= leftResult.sum &amp;&amp; rightResult.sum &gt;= crossResult.sum){\n                return rightResult;\n            }else {\n                return crossResult;\n            }\n        }\n    }\n\n    public static void main(String[] args){\n        int[] A = {12, -3, -16, 20, -19, -3, 18, 20, -7, 12, -9, 7, -10};\n        System.out.println(FindMaxSubarray(A,0,A.length-1).toString());\n    }\n}\n</code></pre>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><hr>\n<blockquote>\n<p>动态规划通常用于解决最优化问题，在这类问题中，通过做出一组选择来达到最优解。在做出每个选择的同时，通常会生成与原问题形式相同的子问题。当多于一个选择子集都生成相同的子问题时，动态规划技术通常就会很有效，其关键技术就是对每个这样的子问题都保存其解，当其重复出现时即可避免重复求解。</p>\n</blockquote>\n<ul>\n<li>动态规划<code>（Dynamic Programming）</code>在数学上属于运筹学的一个分支，是求解决策过程 <code>（decision process）</code>最优化的数学方法，同时也是计算机科学与技术领域中一种常见的算法思想。</li>\n<li>动态规划算法与我们前面提及的分治算法相似，都是==通过组合子问题的解来求解原问题的解==。但是两者之间也有很大区别：<ul>\n<li>分治法将问题划分为互不相交的子问题，递归的求解子问题，再将他们的解组合起来求解原问题的解；与之相反，动态规划应用于子问题相互重叠的情况，在这种情况下，分治法还是会做很多重复的不必要的工作，他会反复求解那些公共的子问题，而动态规划算法则对相同的每个子问题只会求解一次，将其结果保存起来，避免一些不必要的计算工作。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"钢条切割问题\"><a href=\"#钢条切割问题\" class=\"headerlink\" title=\"钢条切割问题\"></a>钢条切割问题</h3><ul>\n<li><p>某个钢材公司购买长钢条，将其切割为短钢条出售，其中切割过程本身不考虑成本，公司管理层想知道最赚钱的钢材切割方案。假设我们知道该钢材公司出售一段长度为 i 米的钢条的价格为 $p(i)$ ，对应的价目表如下：</p>\n<p>|i        |1    |2    |3    |4    |5    |6    |7    |8    |9    |10|<br>|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|<br>|p(i)    |1    |5    |8    |9    |10    |17    |17    |20    |24    |30|</p>\n</li>\n<li><p>所以，钢材切割问题的定义如下：当我们给定一段长度为 $n$ 米的钢条和对应的一个价格表（ $p(i)$, i = 1,2,3,…n)，求一个钢条切割方案，使得最终的销售收益 $r(n)$ 最大。注意：如果长度为 $n$ 英尺的钢条的价格 $p_n$  足够大，那么最优解就是不需要切割。（在这里，我们要求切割的钢条必须为整米长度）</p>\n</li>\n<li><p><strong>问题分析</strong> ：考虑  = 4 的情况，那么有以下几种切割方式：</p>\n<ol>\n<li><p>切割为四段，长度为：1，1，1，1；总共卖$4×1=4$元。</p>\n</li>\n<li><p>切割为三段，长度为：1，1，2；总共卖$2×1+1×5=7$元。</p>\n</li>\n<li><p>切割为两段，长度为：1，3；总共卖$1×1+1×8=9$元。</p>\n</li>\n<li><p>切割为两段，长度为：2，2；总共卖$2×5=10$元。</p>\n</li>\n<li><p>不切割，长度为：4；总共卖$1×9=9$元。</p>\n<p><img data-src=\"https://z3.ax1x.com/2021/04/12/cDHnsJ.jpg\" alt=\"\"></p>\n</li>\n</ol>\n</li>\n</ul>\n<hr>\n<ul>\n<li>长度为 $n$ 的钢条，总共有 $2^{n-1}$ 种不同的切割方案，因为长度为 $n$ 的钢条，总共有 $n-1$ 个缝隙，每个缝隙都可以选择切或不切，==所以有 $2^{n-1}$  种不同切割方案。所以随着 $n$ 增大，切割方案总数呈指数级上升，遍历是不现实的==。在这里，很容易想到，当要分析长度为 $n$ 的钢条的最优解时，可以先将钢条切成两段。==将长度为 $n$ 的钢条随意切割的方案是 $2^{n-1}$ 种，但是只切两段的方案只有 $n-1$ 种，这样规避了指数级计算量==。将切成的两段，分别再当作子问题去求解，这就是如下分治策略解法：</li>\n</ul>\n<h4 id=\"自顶向下递归实现\"><a href=\"#自顶向下递归实现\" class=\"headerlink\" title=\"自顶向下递归实现\"></a>自顶向下递归实现</h4><pre><code class=\"lang-java\">  int CutRod(const int *p, int n)\n{\n    if (n == 0)\n    {\n        return 0;\n    }\n\n    int q = -1;\n    for (int i = 1; i &lt;= n; ++i)\n    {\n        int tmp = p[i] + CutRod(p, n - i);\n        if (q &lt; tmp)\n        {\n            q = tmp;\n        }\n    }\n\n    return q;\n}\n</code></pre>\n<ul>\n<li>自顶向下递归实现的<code>CutRod</code>效率很差，原因在于<code>CutRod</code>反复地用相同的参数值对自身进行递归调用，即它反复求解相同的子问题。它的运行时间为$T(n)=2^n$。对于长度为n的钢条<code>CutRod</code>考察了所有$2^{n-1}$种可能的切割方案。递归调用树共有$2^{n-1}$个叶结点，每个叶结点对应一种可能的切割方案。</li>\n</ul>\n<h4 id=\"动态规划算法一：带备忘录的自顶向下法\"><a href=\"#动态规划算法一：带备忘录的自顶向下法\" class=\"headerlink\" title=\"动态规划算法一：带备忘录的自顶向下法\"></a>动态规划算法一：带备忘录的自顶向下法</h4><pre><code class=\"lang-java\">    int MemoizedCutRodAux(const int *p, int n, int *r)\n    {\n        if (r[n] &gt;= 0)\n        {\n            return r[n];            //首先检查所需的值是否存在\n        }\n\n        int q = -1;\n        if (n == 0)\n        {\n            q = 0;\n        }\n        else\n        {\n            for (int i = 1; i &lt;= n; ++i)\n            {\n                int tmp = p[i] + MemoizedCutRodAux(p, n - i, r);\n                if (q &lt; tmp)\n                {\n                    q = tmp;\n                }\n            }\n        }\n        r[n] = q;\n\n        return q;\n    }\n\n    int MemoizedCutRod(const int *p, int n)\n    {\n        int *r = new int[n + 1];\n        for (int i = 0; i &lt;= n; ++i)\n        {\n            r[i] = -1;\n        }\n\n        return MemoizedCutRodAux(p, n, r);\n    }\n</code></pre>\n<ul>\n<li><p>上述代码与分治不同的地方在于初始化了数组<code>r[n]</code>，将不同长度的最优解数值，储存在了该数组中，所以当不同的 $n$ 传进来时，如果在数组 $r$ 中有当前钢条长度的记录（<code>if r[n] &gt;= 0 : return r[n]</code>)，则直接返回结果，不再进行之后的计算，其余的递归思路与分治策略完全一样。此方法的时间复杂度为 $O(n^2)$  ，变为了多项式时间复杂度。可见，==动态规划算法用少量的空间，显著提升了算法效率。==</p>\n</li>\n<li><p>自顶向下的动态规划算法，仍然不是最理想的。例如在计算 $n =4 $时， $n = 0 $的情况被计算了8次，采用了备忘录的形式之后，虽然 $n = 0$  的情况只需要计算1次，查表有7次操作，但是这7次查表操作，都是在进入了一个相同的函数中，会有频繁的递归函数调用的开销。采用自底向上的动态规划算法，就可以规避这个问题。</p>\n</li>\n</ul>\n<h4 id=\"动态规划算法二：自底而上法\"><a href=\"#动态规划算法二：自底而上法\" class=\"headerlink\" title=\"动态规划算法二：自底而上法\"></a>动态规划算法二：自底而上法</h4><pre><code class=\"lang-java\">int BottomUpCutRod(const int *p, int n)\n{\n    int *r = new int[n + 1];\n    r[0] = 0;\n\n    for (int i = 1; i &lt;= n; ++i)\n    {\n        int q = -1;\n        for (int j = 1; j &lt;= i; ++j)\n        {\n            int tmp = p[j] + r[i - j];\n            q = q &gt; tmp ? q : tmp;\n        }\n        r[i] = q;\n    }\n\n    return r[n];\n}\n</code></pre>\n<ul>\n<li><p>自底向上法不再使用函数递归调用，而采用子问题的自然顺序。在切割时，先由最小的1开始切割，若 $i&lt;j$ ，则规模为 $j$ 的解中一定包含了规模为 $i$ 的全部解（此时子问题的规模，可以理解为之前递归函数的输入 $n$ ）。</p>\n</li>\n<li><p>上述代码中，仍然先初始化一个数组 $r$  ，用于记录不同规模子问题的最优解，并且将 <code>r[0]</code>  初始化为 0 ；之后对 $j = 1，2，… ，n$进行升序求解。不同于之前算法的是，此时直接访问 <code>r[j-i]</code> 来获得规模为 $j-i$ 的子问题的解。因为自底向上求解时，若 $i&lt;j$，当在求解规模为 $j$ 的子问题时， <code>r[i]</code> 一定有数值，因为之前一定已经计算过。</p>\n</li>\n<li><p>自底向上算法的时间复杂度也为，但是避免了大量的递归函数调用的开销，算法更加稳定。</p>\n</li>\n</ul>\n<h2 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h2><ul>\n<li>贪心算法（<code>greedy algorithm</code>）是在对问题求解时，总是做出在当前看来是最好的选择。也就是说，==不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解==。</li>\n<li>贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。————摘自Wikipedia</li>\n</ul>\n<blockquote>\n<p>贪心算法与动态规划算法的最大区别在于：贪心算法每次选择的时候都是按照贪心策略来选择的，满足当前情况的最优解，但是并不一定会是整体最优解；动态规划算法在选择考虑时会考虑所有的子情况，选择最优解，这会是整体的最优解。</p>\n</blockquote>\n<h3 id=\"关键与实现过程\"><a href=\"#关键与实现过程\" class=\"headerlink\" title=\"关键与实现过程\"></a>关键与实现过程</h3><ul>\n<li><strong>关键</strong><ol>\n<li>创建数学模型来描述问题。</li>\n<li>把求解的问题分成若干个子问题。</li>\n<li>对每一子问题求解，得到子问题的局部最优解。</li>\n<li>把子问题的解局部最优解合成原来解问题的一个解。</li>\n</ol>\n</li>\n<li><strong>实现该算法的过程</strong><ul>\n<li>从问题的某一初始解出发；<code>while</code> 能朝给定总目标前进一步 <code>do</code>，求出可行解的一个解元素；最后，由所有解元素组合成问题的一个可行解。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"贪心算法的可行条件\"><a href=\"#贪心算法的可行条件\" class=\"headerlink\" title=\"贪心算法的可行条件\"></a>贪心算法的可行条件</h3><ol>\n<li><p><strong>贪心选择</strong> ： 当某一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且每次做出的选择可以依赖以前做出的选择，但不需要依赖后面需要做出的选择。这就是贪心选择性质。对于一个具体问题，要确定它是否具有贪心选择性质，必须==证明每一步所作的贪心选择最终导致问题的整体最优解==。</p>\n</li>\n<li><p><strong>最优子结构</strong> ： 如果一个问题的最优解包含其子问题的最优解，则此问题具备最优子结构的性质。问题的最优子结构性质是该问题是否可以用贪心算法求解的关键所在。<br>贪心算法与动态规划算法求解的问题类似，都需要满足最优子结构的性质。</p>\n</li>\n</ol>\n<h3 id=\"贪心算法之分饼干\"><a href=\"#贪心算法之分饼干\" class=\"headerlink\" title=\"贪心算法之分饼干\"></a>贪心算法之分饼干</h3><ul>\n<li><strong>题目概述</strong><ul>\n<li>有一群孩子和一堆饼干，每个孩子有一个饥饿度，每个饼干都有一个大小。每个孩子只能吃最多一个饼干，且只有饼干的大小大于孩子的饥饿度时，这个孩子才能吃饱。求解最多有多少孩子可以吃饱。</li>\n</ul>\n</li>\n<li><p><strong>输入输出样例</strong></p>\n<ul>\n<li>输入两个数组，分别代表孩子的饥饿度和饼干的大小。输出最多有多少孩子可以吃饱的数量。</li>\n</ul>\n<pre><code class=\"lang-yml\">Input: [1,2],[1,2,3]\nOutput: 2\n</code></pre>\n<ul>\n<li>在这个样例中，我们可以给两个孩子喂 <code>[1,2]、[1,3]、[2,3]</code> 这三种组合的任意一种。</li>\n</ul>\n</li>\n<li><strong>题解</strong><ul>\n<li>因为饥饿度最小的孩子最容易吃饱，所以我们先考虑这个孩子。为了尽量使得剩下的饼干可以满足饥饿度更大的孩子，所以我们应该把大于等于这个孩子饥饿度的、且大小最小的饼干给这个孩子。满足了这个孩子之后，我们采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，直到没有满足条件的饼干存在。</li>\n<li>简而言之，这里的贪心策略是，给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干。至于具体实现，因为我们需要获得大小关系，一个便捷的方法就是把孩子和饼干分别排序。这样我们就可以从饥饿度最小的孩子和大小最小的饼干出发，计算有多少个对子可以满足条件。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li><strong>排列组合遍历</strong><pre><code class=\"lang-java\">class Solution {\n  public int findContentChildren(int[] g, int[] s) {\n      Arrays.sort(g); //孩子饥饿度数组\n      Arrays.sort(s); //饼干大小数组\n      int numOfChildren = g.length, numOfCookies = s.length;\n      int count = 0;\n      for (int i = 0, j = 0; i &lt; numOfChildren &amp;&amp; j &lt; numOfCookies; i++, j++) {\n          while (j &lt; numOfCookies &amp;&amp; g[i] &gt; s[j]) {\n              j++;\n          }\n          if (j &lt; numOfCookies) {\n              count++;\n          }\n      }\n      return count;\n  }\n}\n</code></pre>\n</li>\n</ul>\n<hr>\n<ul>\n<li><strong>贪心策略</strong><pre><code class=\"lang-java\">public int findContentChildren(int[] grid, int[] size) {\n  if (grid == null || size == null) return 0;\n  Arrays.sort(grid);\n  Arrays.sort(size);\n  int gi = 0, si = 0;\n  while (gi &lt; grid.length &amp;&amp; si &lt; size.length) {\n      if (grid[gi] &lt;= size[si]) {\n          gi++;\n      }\n      si++;\n  }\n  return gi;\n}\n</code></pre>\n</li>\n</ul>\n<h3 id=\"贪心算法之分糖果\"><a href=\"#贪心算法之分糖果\" class=\"headerlink\" title=\"贪心算法之分糖果\"></a>贪心算法之分糖果</h3><ul>\n<li><strong>题目概述</strong><ul>\n<li>一群孩子站成一排，每一个孩子有自己的评分。现在需要给这些孩子发糖果，规则是如果一个孩子的评分比自己身旁的一个孩子要高，那么这个孩子就必须得到比身旁孩子更多的糖果；所有孩子至少要有一个糖果。求解最少需要多少个糖果。</li>\n</ul>\n</li>\n<li><p><strong>输入输出样例</strong></p>\n<ul>\n<li>输入是一个数组，表示孩子的评分。输出是最少糖果的数量。</li>\n</ul>\n<pre><code class=\"lang-yml\">Input: [1,0,2]\nOutput: 5\n</code></pre>\n<ul>\n<li>在这个样例中，最少的糖果分法是 <code>[2,1,2]</code>。</li>\n</ul>\n</li>\n<li><p><strong>题解</strong></p>\n<ul>\n<li>我们只需要简单的两次遍历即可：把所有孩子的糖果数初始化为 1；先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1；再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1。通过这两次遍历，分配的糖果就可以满足题目要求了。这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一侧的大小关系。</li>\n<li>在样例中，我们初始化糖果分配为<code>[1,1,1]</code>，第一次遍历更新后的结果为 <code>[1,1,2]</code>，第二次遍历更新后的结果为<code>[2,1,2]</code>。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li><strong>二次遍历代码</strong><pre><code class=\"lang-java\">class Solution {\n  public int candy(int[] ratings) {\n      int n = ratings.length;\n      int[] left = new int[n];\n      for (int i = 0; i &lt; n; i++) {\n          if (i &gt; 0 &amp;&amp; ratings[i] &gt; ratings[i - 1]) {\n              left[i] = left[i - 1] + 1;\n          } else {\n              left[i] = 1;\n          }\n      }\n      int right = 0, ret = 0;\n      for (int i = n - 1; i &gt;= 0; i--) {\n          if (i &lt; n - 1 &amp;&amp; ratings[i] &gt; ratings[i + 1]) {\n              right++;\n          } else {\n              right = 1;\n          }\n          ret += Math.max(left[i], right);\n      }\n      return ret;\n  }\n}\n</code></pre>\n</li>\n</ul>\n<hr>\n<ul>\n<li><strong>贪心策略代码</strong><pre><code class=\"lang-java\">class Solution {\n  public int candy(int[] ratings) {\n      int[] left = new int[ratings.length];\n      int[] right = new int[ratings.length];\n      Arrays.fill(left, 1);\n      Arrays.fill(right, 1);\n      for(int i = 1; i &lt; ratings.length; i++)\n          if(ratings[i] &gt; ratings[i - 1]) left[i] = left[i - 1] + 1;\n      int count = left[ratings.length - 1];\n      for(int i = ratings.length - 2; i &gt;= 0; i--) {\n          if(ratings[i] &gt; ratings[i + 1]) right[i] = right[i + 1] + 1;\n          count += Math.max(left[i], right[i]);\n      }\n      return count;\n  }\n}\n</code></pre>\n</li>\n</ul>\n",
            "tags": [
                "算法与数据结构"
            ]
        }
    ]
}