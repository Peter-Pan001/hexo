{
    "version": "https://jsonfeed.org/version/1",
    "title": "理 想 净 土 • All posts by \"数据分析\" tag",
    "description": "不必匆忙，不必火花四溅，不必成为别人，只需成为自己",
    "home_page_url": "https://github.com/Peter-Pan001/my-blog",
    "items": [
        {
            "id": "https://github.com/Peter-Pan001/my-blog/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/informatica%E6%89%A9%E5%B1%95",
            "url": "https://github.com/Peter-Pan001/my-blog/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/informatica%E6%89%A9%E5%B1%95",
            "title": "informatica扩展",
            "date_published": "2022-06-05T08:09:22.000Z",
            "content_html": "<h2 id=\"powercenter-cdc\"><a class=\"markdownIt-Anchor\" href=\"#powercenter-cdc\">#</a> PowerCenter CDC</h2>\n<ul>\n<li>CDC 全称 Change Data Capture ，即变化数据捕获 。CDC 的执行原理是通过读取<mark>数据库日志</mark> 获得数据库表的增量数据。</li>\n</ul>\n<h3 id=\"三种模式\"><a class=\"markdownIt-Anchor\" href=\"#三种模式\">#</a> 三种模式</h3>\n<ul>\n<li><strong>CDC Real-Time</strong>\n<ul>\n<li>基于 CDC 技术读取数据库日志，获得数据库增量数据，并实时将数据直接写入目标数据库</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>优势： 1. 可获取数据库增量数据 ； 2. 数据同步准实时，延迟秒级别</p>\n</blockquote>\n<blockquote>\n<p>缺点： 占用源数据库资源 ；多进程运行造成资源抢占 ，需要 CDC Batch 解决</p>\n</blockquote>\n<ul>\n<li><strong>CDC Batch</strong>\n<ul>\n<li>也是基于 CDC 技术原理，只不过延迟为分钟级别</li>\n<li>所有 PowerCenter 的业务要使用 CDC 前，都要进行注册</li>\n<li>注册后的业务表会生成日志 log 文件，powerExchange 就会不断地读取这些 log 文件上的增量数据，并把它存放到临时文件 Condense File 上，当下游数据系统有需求时，在从临时文件中按需获取，大大降低数据库并发性能损耗</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/05/XwkJYj.png\" alt=\"zxa\"></p>\n",
            "tags": [
                "数据分析"
            ]
        },
        {
            "id": "https://github.com/Peter-Pan001/my-blog/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/informatica%E4%B9%8BWorkflow%E7%9B%91%E6%8E%A7",
            "url": "https://github.com/Peter-Pan001/my-blog/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/informatica%E4%B9%8BWorkflow%E7%9B%91%E6%8E%A7",
            "title": "informatica之Workflow监控",
            "date_published": "2022-06-05T07:32:56.000Z",
            "content_html": "<h2 id=\"session\"><a class=\"markdownIt-Anchor\" href=\"#session\">#</a> Session</h2>\n<ul>\n<li>Session 是 Workflow 最基础的组成单元，即一个 Mapping 的实例化</li>\n<li>Mapping 只是一个 program ，仅描述业务逻辑，但对于执行，一些具体参数需要依靠 Session 进行配置，如源数据库、目标数据库、字符集等</li>\n<li>实际上 Session 为 Mapping 提供配置</li>\n</ul>\n<h3 id=\"reusable-session\"><a class=\"markdownIt-Anchor\" href=\"#reusable-session\">#</a> Reusable Session</h3>\n<blockquote>\n<p>一次创建，多次使用</p>\n</blockquote>\n<ul>\n<li>在 Workflow Manager 选择 <code>Task Developer</code> ，在 sub-menu 选择 Tasks—&gt;Create, 输入创建的 Session 名即可</li>\n</ul>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/05/Xwklm8.png\" alt=\"fd\"></p>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/05/Xwk10S.png\" alt=\"qv\"></p>\n<blockquote>\n<p>若在 Mapping 的 Folder 中出现黄色问号或红色感叹号则说明该 Mapping 不合法，需要到 Designer 排查 Mapping 的合法性</p>\n</blockquote>\n<h3 id=\"非reusable-session\"><a class=\"markdownIt-Anchor\" href=\"#非reusable-session\">#</a> 非 Reusable Session</h3>\n<ul>\n<li>使用非 Reusable Session 的前提是有一个 Workflow，在 WFM 中选择 Designer，创建一个新的 Workflow</li>\n<li>此时新的 workflow 仅有一个虚拟的开始点，此时需要同 Reusable Session 一样创建一个 Session ，并用连接线将开始点连接</li>\n</ul>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/05/Xwk3Tg.png\" alt=\"xz\"></p>\n<blockquote>\n<p>左为非 Reusable ，右为 Reusable</p>\n</blockquote>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/05/XwkGkQ.png\" alt=\"ozx\"></p>\n<blockquote>\n<p>仅有非 Reusable 转为 Reusable，反之失败</p>\n</blockquote>\n",
            "tags": [
                "数据分析"
            ]
        },
        {
            "id": "https://github.com/Peter-Pan001/my-blog/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/Informatica%E4%B9%8BPC%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6",
            "url": "https://github.com/Peter-Pan001/my-blog/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/Informatica%E4%B9%8BPC%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6",
            "title": "Informatica之PC基础组件",
            "date_published": "2022-06-04T09:54:40.000Z",
            "content_html": "<h2 id=\"source组件\"><a class=\"markdownIt-Anchor\" href=\"#source组件\">#</a> Source 组件</h2>\n<ul>\n<li>\n<p>在 PowerCenter 中，数据可以是数据库表 Table、文本文件 File、XML 文件、SAP 等应用系统、Hadoop、MQ 等</p>\n</li>\n<li>\n<p>数据源定义的方式</p>\n<ul>\n<li>手工创建（极少使用，过于繁杂）\n<ul>\n<li>数据 DB 名后，对各个 table 的各个 field、Data Type、PK 和 FK 进行配置，当表有很多是，配置相当复杂</li>\n</ul>\n</li>\n<li>通过数据库导入（常用！）\n<ul>\n<li>先建立数据库的 ODBC 链接（仅导入库表结构），然后导入源的结构</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数据库源\"><a class=\"markdownIt-Anchor\" href=\"#数据库源\">#</a> 数据库源</h3>\n<blockquote>\n<p>下面将 PowerCenter Designer 简称 PCD ，将 WorkFlow Manager 简称 WFM</p>\n</blockquote>\n<ul>\n<li>\n<p>在 PCD 层面：</p>\n<ul>\n<li>数据库源的定义按照 Owner Name 进行分组</li>\n<li>源表结构定义虽然继承了数据库中的表定义。但数据类型会发生变化进而导致 Session 执行异常</li>\n<li>PowerCenter 的 PK、FK 是逻辑层面定义的，能与数据库不同</li>\n</ul>\n</li>\n<li>\n<p>在 WFM 层面：</p>\n<ul>\n<li>可在 WFM 指定表名和 Schema（用户名），来对数据库进行连接</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"文本文件源\"><a class=\"markdownIt-Anchor\" href=\"#文本文件源\">#</a> 文本文件源</h3>\n<ul>\n<li>在 PCD 和 WFM 层面，有些文本文件源的属性都可以在这两个层面配置，但 WFM 的优先级更高</li>\n<li>在 PCD：\n<ul>\n<li>Flat File 源在 PowerCenter 中添加一列 <code>CurrentlyyProcessedFileName</code>  对数据进行时间戳修改</li>\n</ul>\n</li>\n<li>在 WFM：\n<ul>\n<li>两个属性：\n<ul>\n<li>Input Type ： 默认文本文件输入 ；若选择 Command ，则将命令的输出作为输入（当文件名不固定时使用更高效）</li>\n<li>Source File Type ：可为 Direct ，指定一个含实际数据的文件名；或为 Indirect，指定一个文件列表（如 txt 文件），里面的.dat 文件才是真正的含数据文件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"target组件\"><a class=\"markdownIt-Anchor\" href=\"#target组件\">#</a> Target 组件</h2>\n<blockquote>\n<p>Target 的定义创建于 Source 一致，即可手动创建也可通过数据库连接导入</p>\n</blockquote>\n<h3 id=\"数据库目标\"><a class=\"markdownIt-Anchor\" href=\"#数据库目标\">#</a> 数据库目标</h3>\n<ul>\n<li>与 Source 的定义类似，在 WFM 中可以使用 Target 表名和 Schema 名定义</li>\n<li>三大在 WFM 使用的选项：\n<ul>\n<li><code>Truncate Target table option</code>  ： 将数据导入 target 前将 target 清空</li>\n<li><code>Target Load Type</code>  :\n<ul>\n<li>Normal: 默认使用</li>\n<li>Bulk：仅支持部分 DB，当可用时，提升写入性能</li>\n</ul>\n</li>\n<li><code>Reject File</code>  ：\n<ul>\n<li>控制异常数据的机制，当发生 PK 冲突导致数据无法插入数据库时，PC 会吧其数据写入 RejectFile，并反馈到开发者解决</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"文本文件目标\"><a class=\"markdownIt-Anchor\" href=\"#文本文件目标\">#</a> 文本文件目标</h3>\n<ul>\n<li>在 PCD 层面\n<ul>\n<li>通过定义文件名端口，可将不同数据写入不同的文件</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/05/XwFOwF.png\" alt=\"saw\"></p>\n<ul>\n<li>在 WFM 层面\n<ul>\n<li>Flat File 作为目标可直接写入本地，或远程 FTP 、Queue，或使用 Loader 工具将 Flat File 加载到 DB</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"expression表达式组件\"><a class=\"markdownIt-Anchor\" href=\"#expression表达式组件\">#</a> Expression 表达式组件</h2>\n<blockquote>\n<p>该组件主要有做行级表达式计算，如多某个 field 进行四则运算等</p>\n</blockquote>\n<ul>\n<li>\n<p>在 Expression 组件中，每个字段都有基本的数据类型以及字段长度的设置，但与其他组件不同的是多出了 I、O、V 三个选项：</p>\n<ul>\n<li>I 即 Input</li>\n<li>O 即 Output</li>\n<li>V 即 Variable</li>\n</ul>\n</li>\n<li>\n<p>关于 Expression 选项，则是对字段的运算表达式填写</p>\n</li>\n</ul>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/05/XwFzWR.png\" alt=\"qwr\"></p>\n<h2 id=\"filter组件\"><a class=\"markdownIt-Anchor\" href=\"#filter组件\">#</a> Filter 组件</h2>\n<blockquote>\n<p>该组件将不满足条件的数据过滤掉</p>\n</blockquote>\n<blockquote>\n<p>下图是将 SAL 字段过滤，筛选出 SAL 低于 5000 的数据</p>\n</blockquote>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/05/Xwk9Qx.png\" alt=\"qix\"></p>\n<h2 id=\"source-qualifier\"><a class=\"markdownIt-Anchor\" href=\"#source-qualifier\">#</a> Source Qualifier</h2>\n<blockquote>\n<p>主要用于连接数据源，将数据源中的数据类型转换为 PowerCenter 的数据类型，相当于一个万能插头，兼容各大数据库厂商</p>\n</blockquote>\n<h3 id=\"使用场景\"><a class=\"markdownIt-Anchor\" href=\"#使用场景\">#</a> 使用场景</h3>\n<ol>\n<li>异构的数据库源表需要进行 Join 计算\n<ul>\n<li>如两张表分别来自 Oracle 和 DB2 ，Oracle 的关联字段类型为 <code>varchar2</code>  ,DB2 的关联字段类型为 <code>varchar</code>  , 为保证关联后字段的数据类型一致，Source Qualifier 作为 “万金油” 实现数据类型的自动映射</li>\n</ul>\n</li>\n<li>异构的数据库源表与目标表进行数据传输\n<ul>\n<li>即 Source 来自 Sql Server ，Target 来自 MySQL ，Source Quailfier 同样起到兼容作用</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"选项卡奥秘\"><a class=\"markdownIt-Anchor\" href=\"#选项卡奥秘\">#</a> 选项卡奥秘</h3>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/05/XwkVFH.png\" alt=\"qo\"></p>\n<blockquote>\n<p>在 SQ 选项卡中，主要几个常用的选项实际上是 SQL 语句的可视化操作</p>\n</blockquote>\n<ul>\n<li><code>SQL query</code>  —— 查询语句的编写</li>\n<li><code>Source Filter</code>  —— 过滤源表数据</li>\n<li><code>Number of Sorted Port</code>  —— 对所选列进行排序，数字大小即为字段排序数量</li>\n<li><code>Select Distinct</code>  —— 数据去重</li>\n</ul>\n<h2 id=\"sorter组件\"><a class=\"markdownIt-Anchor\" href=\"#sorter组件\">#</a> Sorter 组件</h2>\n<blockquote>\n<p>主要对字段进行升序或降序排列</p>\n</blockquote>\n<h3 id=\"选项卡奥秘-2\"><a class=\"markdownIt-Anchor\" href=\"#选项卡奥秘-2\">#</a> 选项卡奥秘</h3>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/05/XwkefA.png\" alt=\"ucs\"></p>\n<ul>\n<li><code>Case Sensitive</code>  ：是否对大小写敏感</li>\n<li><code>Distinct</code>  ： 数据去重</li>\n<li><code>Null Treated Low</code>  ：是否将空值作为小数</li>\n</ul>\n<h2 id=\"joiner组件\"><a class=\"markdownIt-Anchor\" href=\"#joiner组件\">#</a> Joiner 组件</h2>\n<blockquote>\n<p>主要用于联表操作</p>\n</blockquote>\n<ul>\n<li>两表进行关联操作时，有一方在 PowerCenter 中会被当做是 Master，另一方为 Detail。一般来讲，数据量小的表作为 Master 表。</li>\n</ul>\n<h3 id=\"关联类型\"><a class=\"markdownIt-Anchor\" href=\"#关联类型\">#</a> 关联类型</h3>\n<ul>\n<li>内连接 —— 对应为 Normal Join</li>\n<li>左连接 —— 对应为 Master Outer Join</li>\n<li>右连接 —— 对应为 Detail Outer Join</li>\n<li>全连接 —— 对应为 Full Outer Join</li>\n</ul>\n<blockquote>\n<p>下面举个例子来简述一下各个关联类型</p>\n</blockquote>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/05/Xwkult.png\" alt=\"hvio\"></p>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/05/XwkK6P.png\" alt=\"oia\"></p>\n<h3 id=\"sorted-joiner\"><a class=\"markdownIt-Anchor\" href=\"#sorted-joiner\">#</a> Sorted Joiner</h3>\n<blockquote>\n<p>该方法用于将进入 joiner 的数据有序，进而提升 joiner 性能</p>\n</blockquote>\n<ul>\n<li><code>Sorted Joiner</code>  采用  <code>Sorted-Merge</code>  算法</li>\n<li>非  <code>Sorted Joiner</code>  采用  <code>Nested-Loop</code>  算法</li>\n</ul>\n<h3 id=\"joiner作用\"><a class=\"markdownIt-Anchor\" href=\"#joiner作用\">#</a> Joiner 作用</h3>\n<ol>\n<li>异构数据库表关联</li>\n<li>数据库表与文本文件关联</li>\n<li>文件之间关联</li>\n<li>同构表关联</li>\n</ol>\n<blockquote>\n<p>注意： 一个 Joiner 只能同时对两张表关联，三张表需要两个 joiner</p>\n</blockquote>\n<h3 id=\"self-join-自关联\"><a class=\"markdownIt-Anchor\" href=\"#self-join-自关联\">#</a> Self-Join 自关联</h3>\n<blockquote>\n<p>即同一张表扮演 Master 和 Detail 角色</p>\n</blockquote>\n<ul>\n<li>使用条件：\n<ul>\n<li>在从 Source Qualifier 到 Joiner 的两个分支上，至少一个分支必须在 Source Qualifier 和 Joiner 之间增加一个其他组件。</li>\n<li>Joiner Key 必须是经过排序的。</li>\n<li>Joiner 需要使用 Sorted Input。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"lookup组件\"><a class=\"markdownIt-Anchor\" href=\"#lookup组件\">#</a> Lookup 组件</h2>\n<blockquote>\n<p>最复杂的一个组件 ，主要对查询的字段返回多个值</p>\n</blockquote>\n<h3 id=\"lookup-caching-enabled\"><a class=\"markdownIt-Anchor\" href=\"#lookup-caching-enabled\">#</a> Lookup Caching enabled</h3>\n<ul>\n<li>一个提升性能的选项\n<ul>\n<li>启用后：首先被查表的所有数据被读入 PC ，对 Lookup Condition 中涉及的 Key 与其他字段形成一个索引。 然后 Lookup 表会一条条读取数据，与前面索引进行匹配，发现目标 Key ，将 Key 关联的值往下游传递，没匹配到则将空值传递到下游</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"lookup-sql-override\"><a class=\"markdownIt-Anchor\" href=\"#lookup-sql-override\">#</a> Lookup SQL Override</h3>\n<ul>\n<li>一个提升性能选项\n<ul>\n<li>默认提交到数据库的 SQL 会进行 Order by 排序，会消耗数据库资源</li>\n<li>通过这个选项 实际将后面的排序语句进行注释</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"lookup-source-qualifier-和joiner对比\"><a class=\"markdownIt-Anchor\" href=\"#lookup-source-qualifier-和joiner对比\">#</a> Lookup 、Source Qualifier 和 Joiner 对比</h2>\n<blockquote>\n<p>以下将 Lookup 简写为 LKP ，Source Qualifier 简写为 SQ ，Joiner 简写为 JN</p>\n</blockquote>\n<ul>\n<li>\n<p>功能上：</p>\n<ul>\n<li>SQ 可执行任何 SQL 语句</li>\n<li>JN 可实现四种关联类型 ，但仅能用 <code>=</code>  进行比较</li>\n<li>LKP 不能实现四种关联，但可以用  <code>=</code>  、 <code>&gt;</code>  、 <code>&lt;</code>  比较</li>\n</ul>\n</li>\n<li>\n<p>Active 与 Passive</p>\n<ul>\n<li>SQ 和 JN 是 Active 组件</li>\n<li>LKP 是 Passive 组件</li>\n</ul>\n</li>\n<li>\n<p>执行引擎</p>\n<ul>\n<li>LKP 和 JN 是 PowerCenter</li>\n<li>SQ 是数据库</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"stored-procedure组件\"><a class=\"markdownIt-Anchor\" href=\"#stored-procedure组件\">#</a> Stored Procedure 组件</h2>\n<blockquote>\n<p>在 PowerCenter 可调用数据库的存储过程</p>\n</blockquote>\n<h2 id=\"union组件\"><a class=\"markdownIt-Anchor\" href=\"#union组件\">#</a> Union 组件</h2>\n<blockquote>\n<p>应用于将多张表联合在一起</p>\n</blockquote>\n<h2 id=\"transaction-control组件\"><a class=\"markdownIt-Anchor\" href=\"#transaction-control组件\">#</a> Transaction Control 组件</h2>\n<blockquote>\n<p>一个事务产生器，控制事务的提交与回滚</p>\n</blockquote>\n<h2 id=\"sequence组件\"><a class=\"markdownIt-Anchor\" href=\"#sequence组件\">#</a> Sequence 组件</h2>\n<blockquote>\n<p>类似于数据库的 Sequence ， 每次取值自动增加</p>\n</blockquote>\n<h2 id=\"aggregator组件\"><a class=\"markdownIt-Anchor\" href=\"#aggregator组件\">#</a> Aggregator 组件</h2>\n<blockquote>\n<p>用于数据聚合 ，如求和、求均值、求最值等运算</p>\n</blockquote>\n<h2 id=\"rank组件\"><a class=\"markdownIt-Anchor\" href=\"#rank组件\">#</a> Rank 组件</h2>\n<blockquote>\n<p>用于获取 Top 和 Bottom 的数据</p>\n</blockquote>\n<h2 id=\"update-strategy组件\"><a class=\"markdownIt-Anchor\" href=\"#update-strategy组件\">#</a> Update Strategy 组件</h2>\n<blockquote>\n<p>该组件类似于 SQL 的 Insert、Update 与 Delete 语句</p>\n</blockquote>\n<ul>\n<li>可在 WFM 中配置 Workflow 的 session，对 task 进行配置实现<br>\n<img data-src=\"https://s1.ax1x.com/2022/06/05/XwkMOf.png\" alt=\"asd\"></li>\n</ul>\n<h2 id=\"sql-transformation组件\"><a class=\"markdownIt-Anchor\" href=\"#sql-transformation组件\">#</a> SQL Transformation 组件</h2>\n<blockquote>\n<p>需求： 输入一个表名，开发者通过开发一个 Mapping 返回全表数据</p>\n</blockquote>\n<h3 id=\"script-mode\"><a class=\"markdownIt-Anchor\" href=\"#script-mode\">#</a> Script Mode</h3>\n<ul>\n<li>开发者给该组件发送一个 SQL 语句，让 PowerCenter 执行该语句，并返回该语句执行成功情况</li>\n</ul>\n<h2 id=\"java-transformation组件\"><a class=\"markdownIt-Anchor\" href=\"#java-transformation组件\">#</a> Java Transformation 组件</h2>\n<blockquote>\n<p>借助 Java 代码处理一些特定业务：如判断字段是否含有中文，汉字转拼音，加解密，行列转换等</p>\n</blockquote>\n<h3 id=\"组件简介\"><a class=\"markdownIt-Anchor\" href=\"#组件简介\">#</a> 组件简介</h3>\n<ul>\n<li><strong>Passive 与 Active</strong>\n<ul>\n<li>Passive 的 Java 组件每个输入对应一个输出</li>\n<li>Active 则一个输入对应多个输出</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"router\"><a class=\"markdownIt-Anchor\" href=\"#router\">#</a> Router</h2>\n<blockquote>\n<p>数据分发组件，将总部信息分发到各地的接口机和数据库</p>\n</blockquote>\n",
            "tags": [
                "数据分析"
            ]
        },
        {
            "id": "https://github.com/Peter-Pan001/my-blog/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E5%88%9D%E8%AF%86informatica",
            "url": "https://github.com/Peter-Pan001/my-blog/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E5%88%9D%E8%AF%86informatica",
            "title": "初识informatica",
            "date_published": "2022-06-04T09:19:58.000Z",
            "content_html": "<h2 id=\"informatica\"><a class=\"markdownIt-Anchor\" href=\"#informatica\">#</a> Informatica</h2>\n<ul>\n<li>Informatica 是一个 ETL 工具的供应商公司，旗下的 PowerCenter 产品专门为企业做数据集成服务</li>\n</ul>\n<h3 id=\"三大数据集成\"><a class=\"markdownIt-Anchor\" href=\"#三大数据集成\">#</a> 三大数据集成</h3>\n<ul>\n<li>\n<p><strong>下游集成</strong></p>\n<ul>\n<li>即数据仓库（DW），数据仓库是所有应用系统的下游，所有数据流都会流入数据仓库。</li>\n</ul>\n</li>\n<li>\n<p><strong>中游集成</strong></p>\n<ul>\n<li>即数据交换平台任何平台与他的关系都是对等得到，用于支持所有系统间数据层的数据交换。</li>\n</ul>\n</li>\n<li>\n<p><strong>上游集成</strong></p>\n<ul>\n<li>即主数据平台，且为交易型数据平台。用于管理企业核心数据。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"powercenter架构\"><a class=\"markdownIt-Anchor\" href=\"#powercenter架构\">#</a> PowerCenter 架构</h3>\n<ul>\n<li>PowerCenter 整体架构围绕着 ETL 进行，即对数据进行抽取、转换和加载</li>\n</ul>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/05/XwF7Q0.png\" alt=\"sda\"></p>\n<ul>\n<li>其中包含三个客户端，也有一个服务端，server 和客户端可直接访问 Repository，数据库存放着元数据。</li>\n<li>各个客户端作用：\n<ul>\n<li>Designer - 开发数据抽取逻辑程序</li>\n<li>WorkFlow Manager - 开发 Session</li>\n<li>WorkFlow Monitor - 监控 WF</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>经过更新后，在 Server 和 Repository 之间新增个 Repository Server 服务，实际上是一个进程，进一步提升管理数据能力</p>\n</blockquote>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/05/XwFbLT.png\" alt=\"qr\"></p>\n<ul>\n<li>再深入理解其他的含义：\n<ul>\n<li>Domain：\n<ul>\n<li>是 PowerCenter 服务器对象和服务对象集合</li>\n</ul>\n</li>\n<li>Node：\n<ul>\n<li>现实物理服务器在 PowerCenter 的逻辑名</li>\n</ul>\n</li>\n<li>IS：\n<ul>\n<li>即 Integration Services ，所有 ETL 操作都由其指挥</li>\n</ul>\n</li>\n<li>R：\n<ul>\n<li>即 Repository Service, 访问 Repository 的一道门</li>\n</ul>\n</li>\n<li>Repository：\n<ul>\n<li>数据库某个用户下一系列的表及其中存放的数据，与源数据和 Target 表无关</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/05/XwFLeU.png\" alt=\"rfw\"></p>\n",
            "tags": [
                "数据分析"
            ]
        },
        {
            "id": "https://github.com/Peter-Pan001/my-blog/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/CDC%E6%8A%80%E6%9C%AF",
            "url": "https://github.com/Peter-Pan001/my-blog/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/CDC%E6%8A%80%E6%9C%AF",
            "title": "CDC技术",
            "date_published": "2022-06-03T13:59:07.000Z",
            "content_html": "<ul>\n<li>CDC (全称 change data capture)- 变化数据捕获，是识别源系统中数据何时发生更改的过程，以便下游流程或系统可以对该更改执行操作。一个常见的用例是 <mark>反映不同目标系统中的更改，以便系统中的数据保持同步。</mark></li>\n<li>对于数据库而言，CDC 更像是一种软件的设计模式，用来确定与跟踪以及更改了的数据</li>\n<li>CDC 作为一种数据集成方法，常发生在数据仓库环境中，因为捕获和保留数据状态是数据仓库的核心功能之一。</li>\n</ul>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/03/XaS7zF.png\" alt=\"CDC/01.png\"></p>\n<blockquote>\n<p>以银行常见的数据库事件为例：存款与取款的操作通过对变更数据进行捕获与实时数据传输保证数据的时效性</p>\n</blockquote>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/03/XaSvIx.png\" alt=\"sd\"></p>\n<h2 id=\"etl中的cdc\"><a class=\"markdownIt-Anchor\" href=\"#etl中的cdc\">#</a> ETL 中的 CDC</h2>\n<ul>\n<li>先讲一下 ETL 的概念，所谓 ETL，实际上就是对数据进行提取 Extract、转换 Translate、加载 Load，是一个数据集成过程。数据从各个源中提取并传递到数据仓库中，数据的抽取可通过数据库的批处理查询或 CDC 来获得数据。</li>\n</ul>\n<h2 id=\"cdc实现方法\"><a class=\"markdownIt-Anchor\" href=\"#cdc实现方法\">#</a> CDC 实现方法</h2>\n<h3 id=\"audit-columns-审核列\"><a class=\"markdownIt-Anchor\" href=\"#audit-columns-审核列\">#</a> Audit Columns 审核列</h3>\n<ul>\n<li>常见的方式是在当前的数据库表中添加如： <code>Last_Update</code>  或  <code>Date_Modified</code>  列来检索从上次提取数据以来所变更的行情况。</li>\n<li>主要逻辑：\n<ol>\n<li>获取 target 表的 <code>Created_Time</code>  和  <code>Updated_Time</code>  最大值</li>\n<li>从 source 表中选择 <code>Created_Time</code>  大于 target 表中最大的 <code>Created_Time</code>  所在行，此行为上次执行 CDC 后新建的行</li>\n</ol>\n</li>\n</ul>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/03/XapmJf.png\" alt=\"sc\"></p>\n<ol>\n<li>从 source 表中选择  <code>Created_Time</code>  大于 target 表中  <code>Updated_Time</code>  最大值但小于 target 表  <code>Created_Time</code>  最大值</li>\n</ol>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/03/XapMQg.png\" alt=\"sw\"></p>\n<ol>\n<li>插入 2 中的新行后修改 target 表中 3 的现有行</li>\n</ol>\n<blockquote>\n<p>优势：</p>\n</blockquote>\n<blockquote>\n<p>借由本机应用逻辑构建 ，无需借助第三方工具</p>\n</blockquote>\n<blockquote>\n<p>缺点：</p>\n</blockquote>\n<blockquote>\n<p>增加数据库开销、易出错并出现数据一致性问题、无脚本进行删除跟踪会导致删除语句不会传递到 target 上</p>\n</blockquote>\n<h3 id=\"table-deltas-表-增量\"><a class=\"markdownIt-Anchor\" href=\"#table-deltas-表-增量\">#</a> Table Deltas 表 增量</h3>\n<ul>\n<li>通过数据库快照对比数据库表修改前后的差异，有的也称时间戳查询</li>\n</ul>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/03/Xap8wn.png\" alt=\"ie\"></p>\n<blockquote>\n<p>优势：</p>\n</blockquote>\n<blockquote>\n<p>提供已更改数据的准确视图。仅使用本机 SQL Script</p>\n</blockquote>\n<blockquote>\n<p>缺点：</p>\n</blockquote>\n<blockquote>\n<p>对存储需求增加，需要使用数据源的三个副本： 源数据，修改前快照，修改后快照</p>\n</blockquote>\n<blockquote>\n<p>扩展性较差</p>\n</blockquote>\n<h3 id=\"trigger-based-cdc-基于触发器的cdc\"><a class=\"markdownIt-Anchor\" href=\"#trigger-based-cdc-基于触发器的cdc\">#</a> Trigger-based CDC 基于触发器的 CDC</h3>\n<ul>\n<li>通过定义数据库触发器并在影子表中创建自己的变更日志（change log），触发器在增删改查命令执行前或后进行触发，用于创建更改日志。（SQL Level 执行）</li>\n<li>该方法会导致各个表都需要 Trigger，在进行数据修改时，运行 Trigger 会造成额外性能开销与维护上的管理负担。</li>\n</ul>\n<blockquote>\n<p>优势：</p>\n</blockquote>\n<blockquote>\n<p>shadow table 可提供所有事务的不可变详细日志 ，某些数据库在 SQL API 可提供支持</p>\n</blockquote>\n<blockquote>\n<p>缺点：</p>\n</blockquote>\n<blockquote>\n<p>每次进行数据操作会要求数据库进行多次写入，间接降低数据库性能</p>\n</blockquote>\n<h3 id=\"log-based-change-data-capture-基于日志的cdc\"><a class=\"markdownIt-Anchor\" href=\"#log-based-change-data-capture-基于日志的cdc\">#</a> Log-Based Change Data Capture 基于日志的 CDC</h3>\n<ul>\n<li>数据库包含事务日志（也称为重做日志 transaction log），这些日志存储所有数据库事件，允许在发生崩溃时恢复数据库。</li>\n</ul>\n<p><img data-src=\"https://s1.ax1x.com/2022/06/03/XapaSU.png\" alt=\"ix\"></p>\n<blockquote>\n<p>数据捕获是无需进行应用级更改，无需扫描操作表，会显著降低系统性能</p>\n</blockquote>\n<blockquote>\n<p>优势：</p>\n</blockquote>\n<blockquote>\n<p>对 production 数据库系统的影响最新，各事务无需额外查询 ； 可在多个系统保持 ACID 的可靠性 ；无需修改 production 数据库系统模式</p>\n</blockquote>\n<blockquote>\n<p>弊端：</p>\n</blockquote>\n<blockquote>\n<p>日志记录格式随数据库版本更新而需要修改数据库日志逻辑 ；需要系统管理源数据库更改事件元数据</p>\n</blockquote>\n<h3 id=\"data-integration-platforms-for-change-data-capture-数据集成平台的cdc\"><a class=\"markdownIt-Anchor\" href=\"#data-integration-platforms-for-change-data-capture-数据集成平台的cdc\">#</a> Data Integration Platforms for Change Data Capture 数据集成平台的 CDC</h3>\n<ul>\n<li>数据集成平台可自动挖掘数据库 <code>change log</code>  处理并管理其他元数据</li>\n</ul>\n<h2 id=\"cdc应用实例\"><a class=\"markdownIt-Anchor\" href=\"#cdc应用实例\">#</a> CDC 应用实例</h2>\n<ul>\n<li><strong>将数据流式传输到数据仓库</strong>  – 当今数据管道的核心功能之一是将数据从源数据库移动到数据仓库。这是因为大多数操作数据库并非旨在支持密集的分析处理，而数据仓库非常适合这些类型的操作。在这里，CDC 是数据管道体系结构中的关键步骤，可促进从源数据仓库到目标数据仓库的数据迁移。</li>\n<li><strong>将本地数据迁移到云</strong>  – 当组织希望执行资源密集型操作（如人工智能、机器学习或深度学习）时，他们通常会寻求基于云的数据仓库来促进高度资源密集型的数据处理过程。这样做的原因是，与本地部署相比，在云中运行这些操作的运营成本要低得多，这使得云的即用即付模型成为一个不错的选择。在这里，CDC 可以在促进从本地到云的数据迁移方面发挥重要作用。</li>\n</ul>\n",
            "tags": [
                "数据分析"
            ]
        }
    ]
}